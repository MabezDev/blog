<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Scott Mabin</title>
        <link>https%3A//mabez.dev</link>
        <description>Scott Mabin&#x27;s blog</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https%3A//mabez.dev/tags/llvm/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Mon, 18 Oct 2021 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Rust on Espressif chips - 18-10-2021</title>
                <pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp-rust-18-10-2021/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp-rust-18-10-2021/</guid>
                <description>&lt;p&gt;Now I am working at Espressif I plan on publishing updates roughly every quarter just to keep the community in the loop around the esp rust effort.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;documentation-planning&quot;&gt;Documentation &amp;amp; Planning&lt;&#x2F;h2&gt;
&lt;p&gt;One of the hardest parts in any community project is onboarding new developers, especially in the early stages of a project where API&#x27;s, processes and tooling is changing rapidly; it can be frustrating to work on something one week, and in the next you&#x27;re fighting to get it compiling again. We began work on &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;a book&lt;&#x2F;a&gt; in which we will try to keep as a source of truth for the Rust esp effort. This will include install instructions, tooling guides, ecosystem overviews and much more. &lt;&#x2F;p&gt;
&lt;p&gt;We have also put together a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;esp-rs&#x2F;projects&#x2F;1&quot;&gt;road map project&lt;&#x2F;a&gt; on github, with the aim of managing the project from Espressif&#x27;s point of view, but also to allow new contributors to pick up backlog items. Simply comment in the issue if there is something you&#x27;d like to take a stab at, we&#x27;re more than happy to assist and review. We also host bi-weekly meetings which anyone is welcome to attend, just drop a comment &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;discussions&quot;&gt;in the latest discussion thread&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-the-rust-standard-library-on-espressif-chips&quot;&gt;Using the Rust standard library on Espressif chips&lt;&#x2F;h2&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp-rust-espressif&#x2F;&quot;&gt;the last post&lt;&#x2F;a&gt;, I mentioned that was possible to use the Rust standard library thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt;&#x27;s hard work; well, he&#x27;s been at it again! He pushed forward and managed to upstream the standard library changes required to build &lt;code&gt;std&lt;&#x2F;code&gt; on top of &lt;code&gt;esp-idf&lt;&#x2F;code&gt;. From Rust 1.56 it the changes will be stable, meaning it&#x27;s possible to use the upstream Rust toolchain to build the &lt;code&gt;std&lt;&#x2F;code&gt; platform for any RISC-V Espressif chip! Currently, that only includes the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; but there are more to come. This change also applies to Xtensa chips, however they still require a custom toolchain due to the lack of a backend for Xtensa in upstream LLVM. For more info in the &lt;code&gt;std&lt;&#x2F;code&gt; effort, please see &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;the book&lt;&#x2F;a&gt;. I&#x27;d also like to take this time to thank the upstream Rust developers for the prompt and helpful reviews, in particular &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Amanieu&quot;&gt;@Amanieu&lt;&#x2F;a&gt; for helping us push this over the finish line.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;compiler&quot;&gt;Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;The custom toolchain is a hindrance to developer onboarding, especially if developers have to build it themselves. We now offer a prebuilt toolchain&#x27;s for all common OS&#x27;s under the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust-build&quot;&gt;esp-rs&#x2F;rust-build&lt;&#x2F;a&gt; repository. A few days after a new Rust release we typically have the new compiler ready, unless we run into any issues; speaking of, we now test the compiler with a few projects in CI so hopefully we don&#x27;t ship a broken compiler. Note that this extra compiler step is only required when targeting Espressif&#x27;s Xtensa based chips.&lt;&#x2F;p&gt;
&lt;p&gt;There have been a couple of improvements to the compiler fork since the last post, for one the patch set we have to manage has reduced in size thanks to the &lt;code&gt;std&lt;&#x2F;code&gt; library changes being upstreamed. There is now &lt;code&gt;asm!&lt;&#x2F;code&gt; support for the Xtensa architecture, which also means we have removed the old &lt;code&gt;llvm_asm!&lt;&#x2F;code&gt; macros from the &lt;code&gt;xtensa&lt;&#x2F;code&gt; crates and ported them to the new syntax.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;svds&quot;&gt;SVDs&lt;&#x2F;h3&gt;
&lt;p&gt;SVDs have been coming along very nicely, we now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;svd&#x2F;tree&#x2F;main&#x2F;svd&quot;&gt;have official SVDs&lt;&#x2F;a&gt; for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, &lt;code&gt;esp32s2&lt;&#x2F;code&gt; and the &lt;code&gt;esp32&lt;&#x2F;code&gt;. If you have been following this effort for a while, you may be thinking we already had an &lt;code&gt;esp32&lt;&#x2F;code&gt; SVD, well you would be correct! However, it was very hacky, missed a lot of peripherals and was all around horrible to work with. The new SVD aims to be more complete and importantly more consistent. One thing that has been missing from the official SVDs is interrupt information, however this has recently changed and interrupt information for each peripheral is now available. Overall the SVDs available now are in a great spot to feed into &lt;code&gt;svd2rust&lt;&#x2F;code&gt; and other tooling, ready for HAL creation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;espflash&quot;&gt;&lt;code&gt;espflash&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&quot;&gt;&lt;code&gt;espflash&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a rewrite of Espressif&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esptool&quot;&gt;&lt;code&gt;esptool.py&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, but also has &lt;code&gt;cargo&lt;&#x2F;code&gt; integration. It&#x27;s been under heavy development and now has a &lt;code&gt;1.0&lt;&#x2F;code&gt; release! Including:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Support for flashing:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;esp32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp32c3&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp32s2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp8266&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Compression for faster flashing.&lt;&#x2F;li&gt;
&lt;li&gt;Support for the &lt;code&gt;esp-idf&lt;&#x2F;code&gt; partition table format.&lt;&#x2F;li&gt;
&lt;li&gt;Support for flashing a stock &lt;code&gt;esp-idf&lt;&#x2F;code&gt; bootloader.&lt;&#x2F;li&gt;
&lt;li&gt;Removed support &lt;code&gt;xargo&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;cargo xbuild&lt;&#x2F;code&gt;, now focusing support on &lt;code&gt;build-std&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Reading back flash info.&lt;&#x2F;li&gt;
&lt;li&gt;Reading some EFUSE values.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;elf2image&lt;&#x2F;code&gt; functionality, for writing the formatted image to a file.&lt;&#x2F;li&gt;
&lt;li&gt;Beautiful &amp;amp; helpful error messages with &lt;code&gt;miette&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Big thanks to all the contributors in this release, especially &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;probe-rs&quot;&gt;&lt;code&gt;probe-rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;We have also started adding support for flashing and debugging Espressif chips with &lt;code&gt;probe-rs&lt;&#x2F;code&gt;. As the RISC-V architecture is already supported in &lt;code&gt;probe-rs&lt;&#x2F;code&gt;, we set out to add support for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; initially. We are happy to report that &lt;code&gt;probe-rs&lt;&#x2F;code&gt; master now has a flash algorithm capable of flashing the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;! The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-flash-loader&quot;&gt;&lt;code&gt;esp-flash-loader&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; repository contains the code for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; flash loader, but thanks for Espressif&#x27;s ROM API it should be very easy to port the algorithm to the other chips. Xtensa support for &lt;code&gt;probe-rs&lt;&#x2F;code&gt; is planned eventually, but will take some time to implement. A big thank you to the &lt;code&gt;probe-rs&lt;&#x2F;code&gt; folks, in particular &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Yatekii&quot;&gt;@Yatekii&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Tiwalun&quot;&gt;@Tiwalun&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Dirbaio&quot;&gt;@Dirbaio&lt;&#x2F;a&gt; for the reviews and assistance.&lt;&#x2F;p&gt;
&lt;p&gt;Having &lt;code&gt;probe-rs&lt;&#x2F;code&gt; support gives us easy access to &lt;a href=&quot;https:&#x2F;&#x2F;www.segger.com&#x2F;products&#x2F;debug-probes&#x2F;j-link&#x2F;technology&#x2F;about-real-time-transfer&#x2F;&quot;&gt;RTT&lt;&#x2F;a&gt; for fast, low overhead logging. We have the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; using RTT with &lt;code&gt;probe-rs&lt;&#x2F;code&gt; locally, however a few patches are required due to the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;&#x27;s lack of atomics. Whilst we have contributed to crates such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;atomic-polyfill&#x2F;pull&#x2F;6&quot;&gt;atomic-polyfill&lt;&#x2F;a&gt; these crates are quite intrusive and require other ecosystem crates to depend on them instead of &lt;code&gt;core::sync::atomic&lt;&#x2F;code&gt;. To combat this, we are in the process of writing an atomic emulation trap handler. This works by treating the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; like it has atomic support (build as &lt;code&gt;riscv32imac-unknown-none-elf&lt;&#x2F;code&gt;), and when we trap on the atomic instructions, we decode them and emulate them in software transparently. There is a performance penalty that it is roughly 2-4x slower than native instructions based on our testing, but having an atomic story is important in the embedded Rust ecosystem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Continue to improve the tooling around Rust with Espressif chips, until we have out of the box solutions for most stories. Continue to build and polish standard library use with Espressif chips, as well as the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; story. We would also like to explore using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustc_codegen_gcc&quot;&gt;rustc_codegen_gcc&lt;&#x2F;a&gt; to try and target Espressif&#x27;s Xtensa chips. The end goal will still be to upstream the Xtensa backend to LLVM, but &lt;code&gt;rustc_codegen_gcc&lt;&#x2F;code&gt; may allow targeting Xtensa chips faster as GCC already has a stable Xtensa backend. &lt;&#x2F;p&gt;
&lt;p&gt;Expect another update early next year!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Rust on the ESP32</title>
                <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp32-rust/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp32-rust/</guid>
                <description>&lt;p&gt;About six months ago, I made a &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;ar2d3r&#x2F;espressif_have_finally_released_an_llvm_fork_this&#x2F;&quot;&gt;post on reddit&lt;&#x2F;a&gt; highlighting the launch of Espressif&#x27;s llvm xtensa fork, not too long after, I had a working &lt;code&gt;rustc&lt;&#x2F;code&gt; toolchain capable of generating xtensa assembly. At this point I had to put this project to the side to finish my final year of university. Funnily enough I didn&#x27;t stray too far, my final year project used Rust to create a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MWatch&quot;&gt;&#x27;smartwatch&#x27;&lt;&#x2F;a&gt; (I may write about this in the future, if anyone is interested). &lt;&#x2F;p&gt;
&lt;p&gt;Since then I have seen a few posts utilising my fork to run Rust on the &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;hardware&#x2F;esp32&#x2F;overview&quot;&gt;ESP32&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;dentrassi.de&#x2F;2019&#x2F;06&#x2F;16&#x2F;rust-on-the-esp-and-how-to-get-started&#x2F;&quot;&gt;see this great write up&lt;&#x2F;a&gt; by ctron, if you haven&#x27;t already), most of which are building on top of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-idf&quot;&gt;esp-idf&lt;&#x2F;a&gt; which is written in C. In this post I&#x27;ll be discussing the steps I took to generate valid binaries for the xtensa architecture with &lt;code&gt;rustc&lt;&#x2F;code&gt; and then write some &lt;code&gt;no_std&lt;&#x2F;code&gt; code to build a blinky program for the ESP32 only using Rust!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hacking-the-compiler&quot;&gt;Hacking the compiler&lt;&#x2F;h2&gt;
&lt;p&gt;In March of 2019, Espressif released their first run at an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-xtensa&quot;&gt;llvm fork&lt;&#x2F;a&gt; to support the xtensa architecure. Shortly after I got to work bootstrapping Rust to use this newly created fork. Prior to this project, I&#x27;d had no experience with the compiler, fortunately I came across the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;52787&quot;&gt;RISCV PR&lt;&#x2F;a&gt; which gave me a rough idea of what was required. After &lt;em&gt;many&lt;&#x2F;em&gt; build attempts I finally got it working; I was now able to generate xtensa assembly from Rust source code!&lt;&#x2F;p&gt;
&lt;p&gt;The next step was to assemble and link the generated assembly. The llvm fork in it&#x27;s current state cannot perform object generation, so we must use an external assembler. Luckily Rust allows us to do so by specifying the &lt;code&gt;linker_flavor&lt;&#x2F;code&gt; as &lt;code&gt;gcc&lt;&#x2F;code&gt; and providing a path to the linker with the &lt;code&gt;linker&lt;&#x2F;code&gt; target option, in this case &lt;code&gt;xtensa-esp32-elf-gcc&lt;&#x2F;code&gt;. After that I created a few built-in targets (which you can see &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&#x2F;blob&#x2F;ad570c5cb999f62a03156286fdb5d3d1bbd0fb8b&#x2F;src&#x2F;librustc_target&#x2F;spec&#x2F;xtensa_esp32_none_elf.rs&quot;&gt;here&lt;&#x2F;a&gt;); &lt;code&gt;xtensa-esp32-none-elf&lt;&#x2F;code&gt; for the ESP32; &lt;code&gt;xtensa-esp8266-none-elf&lt;&#x2F;code&gt; for the ESP8266; finally the &lt;code&gt;xtensa-unknown-none-elf&lt;&#x2F;code&gt; target for a generic xtensa target.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blinky-code&quot;&gt;Blinky code&lt;&#x2F;h2&gt;
&lt;p&gt;Now lets try and get a ESP32 board to blink the onboard LED using just Rust. First off, we need our basic program structure. The &lt;code&gt;xtensa_lx6_rt&lt;&#x2F;code&gt; crate does most of the heavy lifting in this respect, we simply need to define an entry point and the panic handler. Some of this may look vaguely familiar if you have any experience with &lt;code&gt;cortex-m&lt;&#x2F;code&gt; development on Rust, I&#x27;ve tried to mirror the API as best as I can.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#![no_std]
#![no_main]


use xtensa_lx6_rt as _;

use core::panic::PanicInfo;

&#x2F;&#x2F;&#x2F; Entry point - called by xtensa_lx6_rt after initialisation
#[no_mangle]
fn main() -&amp;gt; ! {
    loop {}
}

&#x2F;&#x2F;&#x2F; Simple panic handler
#[panic_handler]
fn panic(_info: &amp;amp;PanicInfo) -&amp;gt; ! {
    loop {}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now lets add some register definitions for the peripherals we want to use. For our blinky program, we will need to control the GPIO peripheral. In the ESP32 (and most modern processors) peripherals are mapped to memory adresses, commonly refered to as memory mapped peripherals. To control a peripheral we simply need to write values to the right addresses in memory, with respect to the reference manual supplied by the chip manufacturer.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F;&#x2F; GPIO output enable reg
const GPIO_ENABLE_W1TS_REG: u32 = 0x3FF44024;

&#x2F;&#x2F;&#x2F; GPIO output set register
const GPIO_OUT_W1TS_REG: u32 = 0x3FF44008;
&#x2F;&#x2F;&#x2F; GPIO output clear register
const GPIO_OUT_W1TC_REG : u32 = 0x3FF4400C;

&#x2F;&#x2F;&#x2F; The GPIO hooked up to the onboard LED
const BLINKY_GPIO: u32 = 2;

&#x2F;&#x2F;&#x2F; GPIO function mode
const GPIO_FUNCX_OUT_BASE: u32 = 0x3FF44530;
const GPIO_FUNCX_OUT_SEL_CFG: u32 = GPIO_FUNCX_OUT_BASE + (BLINKY_GPIO * 4);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using these definitions it should be possible to change the gpio for your board&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#gpio_pin&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; by changing the &lt;code&gt;BLINKY_GPIO&lt;&#x2F;code&gt;; for my board (NODEMCU ESP-32S) it was GPIO2.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;initialisation&quot;&gt;Initialisation&lt;&#x2F;h3&gt;
&lt;p&gt;Next lets setup the pin as a GPIO output. For the ESP32, this is a two step process&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#gpio_pin&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. Firstly, its simply a case of setting a bit in the GPIO ouput enable register. Secondly the pin has to be configured in GPIO mode. There are not enough pins for all the possible peripherals in the chip, to combat this each pin can have multiple function modes. In the case of the ESP32, each pin has up to 256 different functions, although not all are mapped. To put the pin in GPIO mode, we need to put in mode 256 (0x100), we do this by writing to the function select register. After issuing those two register writes, we should be able to turn on the GPIO by setting the relevant bit inside the GPIO set register&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#[no_mangle]
fn main() -&amp;gt; ! {

    &#x2F;&#x2F; configure the pin as an output
    unsafe {
        core::ptr::write_volatile(GPIO_ENABLE_W1TS_REG as *mut _, 0x1 &amp;lt;&amp;lt; BLINKY_GPIO);
        &#x2F;&#x2F; 0x100 makes this pin a simple gpio pin - see the technical reference for more info
        core::ptr::write_volatile(GPIO_FUNCX_OUT_SEL_CFG as *mut _, 0x100); 
    }
    &#x2F;&#x2F; turn on the LED
    unsafe {
        core::ptr::write_volatile(GPIO_OUT_W1TS_REG as *mut _, 0x1 &amp;lt;&amp;lt; idx);           
    }
    loop {}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;delaying&quot;&gt;Delaying&lt;&#x2F;h3&gt;
&lt;p&gt;For the next stage of our blinky program, we need a way to delay; a simple approach could use &lt;code&gt;for&lt;&#x2F;code&gt; loop like so.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;pub fn delay(clocks: u32) {
    let dummy_var: u32 = 0;
    for _ in 0..clocks {
        unsafe { core::ptr::read_volatile(&amp;amp;dummy_var) };
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add the volatile read so that the compiler doesn&#x27;t optimise our delay away. The problem with this approach is that depending of the optimisation level, the number of clock cycles each iteration of the loop changes. We need a cycle accurate way of delaying, fortunately the ESP32 has an internal clock counting register which can be accessed with the read special register &lt;code&gt;rsr&lt;&#x2F;code&gt; instruction. Now are delay function looks like this.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F;&#x2F; cycle accurate delay using the cycle counter register
pub fn delay(clocks: u32) {
    &#x2F;&#x2F; NOTE: does not account for rollover
    &#x2F;&#x2F; ommitted: the asm to read the ccount
    let target = get_ccount() + clocks;
    loop {
        if get_ccount() &amp;gt; target {
            break;
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have cycle accurate counting we can delay for one second by waiting for the number of cycles the processor will do in one second. The default clock speed on most ESP boards is 40mhz, hence waiting for 40 million cycles equates to a one second delay.&lt;&#x2F;p&gt;
&lt;p&gt;Bringing the snippets together and cleaning up the code into functions, we now have &lt;code&gt;main&lt;&#x2F;code&gt; that looks like this.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#[no_mangle]
fn main() -&amp;gt; ! {
    &#x2F;&#x2F; configure the pin as an output
    configure_pin_as_output(BLINKY_GPIO);

    loop {
        set_led(BLINKY_GPIO, true);
        delay(CORE_HZ);
        set_led(BLINKY_GPIO, false);
        delay(CORE_HZ);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After flashing to the board, and firing up our JTAG debugger&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, we are greeted with a blinking LED!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;video muted controls style=&quot;width: 100%; height:auto&quot;&gt;
&lt;source src=&quot;&#x2F;esp-rust-blinky.webm&quot; type=&quot;video&#x2F;mp4&quot;&gt;
&lt;&#x2F;video&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The full source can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;the xtensa quickstart repo&lt;&#x2F;a&gt; if you wish to try it for yourself.&lt;&#x2F;p&gt;
&lt;p&gt;Now I know what most of you are thinking at this point, it&#x27;s not very Rusty; it contains bundles of unsafe and there are no real abstractions here, and you are right; but it&#x27;s something to get the ball rolling.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;&#x2F;h2&gt;
&lt;p&gt;There are a few small teething issues, but by far the biggest being issue is that the fork struggles with generating debug info; the external assembler does not support &lt;a href=&quot;https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs-2.24&#x2F;as&#x2F;CFI-directives.html#CFI-directives&quot;&gt;CFI directives&lt;&#x2F;a&gt; something that all llvm targets need to support. CFI directives can easily be removed with some preprocessing, but does of course add an extra step. After pushing past that issue, I was still getting relocation linker errors. I opened &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-xtensa&#x2F;issues&#x2F;10&quot;&gt;an issue&lt;&#x2F;a&gt; to document my findings in the hopes it can be sorted in the next iteration of the llvm fork.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;&#x2F;h2&gt;
&lt;p&gt;Once the debuginfo issue is sorted, I hope to start developing an ecosystem of HAL&#x27;s and drivers similar to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&quot;&gt;stm32-rs&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nrf-rs&quot;&gt;nrf-rs&lt;&#x2F;a&gt;; I&#x27;ve already started the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&quot;&gt;esp-rs&lt;&#x2F;a&gt; organization which is where &lt;code&gt;xtensa-lx6-rt&lt;&#x2F;code&gt; currently resides. Espressif has started the upstream process, the first ten patches are now in review, there should be an update coming to their fork moving from the older llvm6 to llvm8 (and hopefully some other additions and fixes too!).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;xtensa-quickstart&lt;&#x2F;a&gt; - A quickstart project for using Rust on xtensa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&quot;&gt;rust-xtensa&lt;&#x2F;a&gt; - The xtensa fork of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&quot;&gt;github&lt;&#x2F;a&gt; - My github&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;gpio_pin&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Note that this only applies for GPIO&#x27;s 0 to 31, the rest of the GPIO&#x27;s use a different register.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;This is not always the case if the pin the LED is connected to does not default to the correct iomux function, see the quickstart example for more info.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;This step is actually very important, currently the board will reset endlessly on boot (I assume due to the watch dog not being disabled), but launching with the debugger works as expected.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
    </channel>
</rss>
