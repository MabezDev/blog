<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Scott Mabin</title>
        <link>https%3A//mabez.dev</link>
        <description>Scott Mabin&#x27;s blog</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https%3A//mabez.dev/tags/hal/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Tue, 15 Sep 2020 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Rust on the ESP32 &amp; ESP8266 - Building an ecosystem</title>
                <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp-rust-ecosystem/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp-rust-ecosystem/</guid>
                <description>&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;last post, nearly 10 months ago&lt;&#x2F;a&gt; a lot has changed. For one, its not just me working on this any more! Community members are starting to contribute to the various ESP related projects. The extra help meant we have made considerable progress which I will now take you through in this post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-compiler&quot;&gt;The compiler&lt;&#x2F;h2&gt;
&lt;p&gt;I have been working on cleaning up the &lt;code&gt;rustc&lt;&#x2F;code&gt; work, including rebasing regularly to keep up with upstream rustc changes. Recently, I have cleaned up and extracted the patches required to enable &lt;code&gt;Xtensa&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp&lt;&#x2F;code&gt; development with Rust, firstly to make it easier to rebase onto a newer version of the compiler, but also in the hopes of one day being able to submit these patches upstream when the &lt;code&gt;Xtensa&lt;&#x2F;code&gt; target is upstreamed in llvm. You can see the patchset &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa-patches&quot;&gt;here&lt;&#x2F;a&gt;. On that note, it seems no progress has been made on that front in the last 9 months; whilst Espressif are doing a great job responding to issues and fixing bugs, it seems the patches are stuck in review in llvm. I&#x27;m unsure what directions to take to get more attention to this. &lt;&#x2F;p&gt;
&lt;p&gt;I have also reworked the build process, as well as tagging releases. It is no longer necessary to build LLVM seperately, as I have swapped out the LLVM submodule to the forked one, meaning you can just use normal rust build instructions. Starting now, I will also be tagging releases every time I rebase on upstream master; on top of which I am also offering prebuilt linux (sorry Windows &amp;amp; Mac users) toolchains on the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&#x2F;releases&#x2F;tag&#x2F;xtensa-v0.2.0&quot;&gt;releases&lt;&#x2F;a&gt; (if you are building for Mac or Windows, please feel free to send me your prebuilt toolchains for upload).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling-improvements&quot;&gt;Tooling improvements&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cargo-espflash&quot;&gt;cargo-espflash&lt;&#x2F;h3&gt;
&lt;p&gt;For those of you not familiar with developing on ESP* platforms, there is a flashing tool &lt;code&gt;esptool.py&lt;&#x2F;code&gt; which will flash your program to the device. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; began rewriting this tool in Rust, called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&quot;&gt;espflash&lt;&#x2F;a&gt;. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; then submitted &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;1&quot;&gt;a PR which added a cargo interface&lt;&#x2F;a&gt; to it, meaning we can easily build and flash all in one go, for example building and flashing the blinky example in the ESP32 HAL:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; cargo espflash&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --chip&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; esp32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --example&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; blinky &#x2F;dev&#x2F;ttyUSB0
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s really nice to invoke cargo once, make a coffee, and have your code running on the board when you get back! We&#x27;ve been adding more features to the tool, like reading back board info (flash size, CPU revision etc) in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;3&quot;&gt;#3&lt;&#x2F;a&gt;, and allowing faster flash speeds for the ESP32 in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;5&quot;&gt;#5&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;idf2svd&quot;&gt;idf2svd&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; submitted a PR to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; to add support for generating ESP8266 SVD&#x27;s, of which the esp8266-hal is built upon; &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;if you remeber back to the bonus section of my last post&lt;&#x2F;a&gt;, you will be able to use that SVD to debug ESP8266 applications too!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-runtime-crates&quot;&gt;The runtime crates&lt;&#x2F;h2&gt;
&lt;p&gt;After my last post I set to improve the runtime crate to include support for exceptions, which &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx6-rt&#x2F;pull&#x2F;6&quot;&gt;I started before&lt;&#x2F;a&gt; taking a short break. In that time &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt; championed it, fully implementing exception and interrupt handling for the lx6 CPU of the ESP32! On top of that, for those of you familiar with the &lt;code&gt;cortex-m-rt&lt;&#x2F;code&gt; crates, we implemented the attribute macros for defining &lt;code&gt;#[interrupt]&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;#[exception]&lt;&#x2F;code&gt; handlers and the &lt;code&gt;#[entry]&lt;&#x2F;code&gt; point to the program. Previously &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx6&quot;&gt;&lt;code&gt;xtensa-lx6&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; was empty, but we have since implemented (and moved code from rt where neccessary), including the on chip &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;xtensa-lx6&#x2F;0.2.0&#x2F;xtensa_lx6&#x2F;timer&#x2F;index.html&quot;&gt;timers&lt;&#x2F;a&gt; and a series of &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;xtensa-lx6&#x2F;0.2.0&#x2F;xtensa_lx6&#x2F;mutex&#x2F;index.html&quot;&gt;mutex&lt;&#x2F;a&gt; implementations for the platform.&lt;&#x2F;p&gt;
&lt;p&gt;Meanwhile &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; began writing a runtime crate for the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&#x2F;xtensa-lx106-rt&quot;&gt;lx106&lt;&#x2F;a&gt;, the processor in a ESP8266. We found that between the &lt;code&gt;xtensa-lx&lt;&#x2F;code&gt; series there were not many differences, confirming what a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx-rt&#x2F;issues&#x2F;5#issuecomment-578419057&quot;&gt;core esp-idf developer mentioned&lt;&#x2F;a&gt; previously, therefore we decided to merge the lx6 and lx106 crates producing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx&quot;&gt;&lt;code&gt;xtensa-lx&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx-rt&quot;&gt;&lt;code&gt;xtensa-lx-rt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with features for each silicon revision.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-hal-crates&quot;&gt;The HAL crates&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;esp32&quot;&gt;ESP32&lt;&#x2F;h3&gt;
&lt;p&gt;With the runtime crates in good shape, we now had a good basis to build a HAL (Hardware abstraction layer). I started by submitting a simple &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;commit&#x2F;8a3f2e750335623b551d59419e4e138659cc77aa&quot;&gt;GPIO driver for the ESP32&lt;&#x2F;a&gt; implementing the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;embedded-hal&quot;&gt;embedded-hal digital traits&lt;&#x2F;a&gt;. Since then the features haven&#x27;t stopped coming, primarily thanks once again to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt;. Checkout &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;tree&#x2F;master&#x2F;examples&quot;&gt;the examples&lt;&#x2F;a&gt; to see what you can do with an ESP32 in pure Rust&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#pure-rust&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;! &lt;&#x2F;p&gt;
&lt;h3 id=&quot;esp8266&quot;&gt;ESP8266&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; has since started the ESP8266 HAL. One thing that is slowing down development is the fact that alot of the functions in the C SDK are simply binary blobs (or as Espressif refer to them, ROM functions). It means that re-implementing them in Rust requires disassembly  of the binaries and reverse engineering of the assembly to figure out whats going on. Whilst it is undoubtedly fun, it is a lot harder than looking at the source (which we can do with the ESP32). It&#x27;s coming along nicely though, with support for GPIO, Serial, SPI and much more. Checkout the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp8266-hal&quot;&gt;esp-rs&#x2F;esp8266-hal&lt;&#x2F;a&gt; repo. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; has started a BSP (board support package) for the D1 Mini ESP8266 board, built on top of the esp8266-hal, so if you have one of those board lying around check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&#x2F;d1-mini&quot;&gt;repo&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-quickstart&quot;&gt;The quickstart&lt;&#x2F;h2&gt;
&lt;p&gt;With the compiler changes and HAL&#x27;s being created, the old quickstart needed some love. First on the list removing some unneeded compiler restrictions, mainly around allowing debug info generation, as the LLVM fork now supports that (See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;23&quot;&gt;#23&lt;&#x2F;a&gt;). The biggest change has been adding runnable examples for both the ESP32 &amp;amp; ESP8266; its now easier than ever to Rustup your Esp microcontroller! I have also added &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;blob&#x2F;04f9fb79e9a6a519a3311bc1e5a5e22af7c93f29&#x2F;src&#x2F;main.rs#L1-L55&quot;&gt;a brief overview&lt;&#x2F;a&gt; of how to target a different Xtensa target other than the ESP32 or ESP8266, though I&#x27;m not aware of any other boards using this architecture, would be very interested to hear about it if you are aware of any.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;I&#x27;d love to see more contributors as it&#x27;s easier than ever to contribute if you are familiar with Rust or embedded; both HAL&#x27;s are in a good spot to pick a hardware feature and implement it in Rust! &lt;&#x2F;li&gt;
&lt;li&gt;Myself and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt; are looking &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-wifi&quot;&gt;at WiFi&#x2F;Bluetooth support&lt;&#x2F;a&gt; for the ESP32, but haven&#x27;t had much luck so far. &lt;&#x2F;li&gt;
&lt;li&gt;At some point I&#x27;d like to start looking into integrating with an existing Rust RTOS, perhaps &lt;a href=&quot;https:&#x2F;&#x2F;www.tockos.org&#x2F;&quot;&gt;tockos&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;rtic.rs&#x2F;0.5&#x2F;book&#x2F;en&#x2F;&quot;&gt;rtic&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;At this point I&#x27;d like to say a big thank you to all the contributors who have helped along the way so far!&lt;&#x2F;p&gt;
&lt;p&gt;Finally, if you appreciate the effort going into this, consider joining @davidkern, @DaMouse404 and others &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;mabezdev&quot;&gt;in sponsoring me&lt;&#x2F;a&gt;, it&#x27;s very much appreciated &amp;lt;3.&lt;&#x2F;p&gt;
&lt;iframe src=&quot;https:&#x2F;&#x2F;github.com&#x2F;sponsors&#x2F;MabezDev&#x2F;card&quot; title=&quot;Sponsor MabezDev&quot; height=&quot;225&quot; width=&quot;600&quot; style=&quot;border: 0;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;br&gt;
&lt;hr &#x2F;&gt;
&lt;br&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;pure-rust&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Not quite! We&#x27;re still using the C bootloader to initialize the flash for now. Note that you can run applications entirely in RAM if you wish.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Rust on the ESP32 - SVD&#x27;s, PAC&#x27;s and USB flashing</title>
                <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp32-rust-svd-pac/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp32-rust-svd-pac/</guid>
                <description>&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust&#x2F;&quot;&gt;last post&lt;&#x2F;a&gt; I&#x27;ve been working on building the humble beginnings of an ecosystem around the ESP32 for Rust. The short version of this post is as follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;4&quot;&gt;This PR&lt;&#x2F;a&gt; means the quickstart repo can now flash and run code without a debugger! Simply using the &lt;code&gt;flash&lt;&#x2F;code&gt; or &lt;code&gt;flash_release&lt;&#x2F;code&gt; scripts will flash your code and begin running your code&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; has been created which uses the documentation from &lt;code&gt;esp-idf&lt;&#x2F;code&gt; to generate svd files fit for consumption by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;svd2rust&quot;&gt;svd2rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Based on the generated SVD file, there is now a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;esp32&#x2F;latest&#x2F;esp32&#x2F;&quot;&gt;PAC (Peripheral access crate)&lt;&#x2F;a&gt; for the ESP32.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fixing-xtensa-rust-quickstart&quot;&gt;Fixing &lt;code&gt;xtensa-rust-quickstart&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As noted in my previous post, running Rust applications on the ESP32 required the use of a JTAG debugger as the board would reset repeatedly. My suspicion was a watch dog reset, but my &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;4&#x2F;commits&#x2F;d8d6971285d20aacb6db32a68138c58a77fa9efa&quot;&gt;initial experiments on disabling the watchdog&lt;&#x2F;a&gt; did not appear to be working. I decided to inspect the openocd source to see what the debugger does when it connects, it turns out that the ESP32 has another 2 timer based watch dogs as seen &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;openocd-esp32&#x2F;blob&#x2F;97ba3a6bb9eaa898d91df923bbedddfeaaaf28c9&#x2F;src&#x2F;target&#x2F;esp32.c#L431&quot;&gt;being disabled by openocd here&lt;&#x2F;a&gt;; after disabling those two watchdogs, its was possible to flash and run code with just the USB cable connected!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-the-esp32-peripheral-access-crate&quot;&gt;Creating the &lt;code&gt;esp32&lt;&#x2F;code&gt; peripheral access crate&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;http:&#x2F;&#x2F;www.keil.com&#x2F;pack&#x2F;doc&#x2F;CMSIS&#x2F;SVD&#x2F;html&#x2F;index.html&quot;&gt;SVD format&lt;&#x2F;a&gt; was created for ARM processors, but as it turns out it works very well for other processor architectures too. Espressif (unsuprisingly) don&#x27;t provide an SVD file, so I would have to create my own; but before I move on to that, what do we actually get from creating and SVD file for the ESP32? Well, it allows us to use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;svd2rust&quot;&gt;svd2rust&lt;&#x2F;a&gt; to generate really nice register access API&#x27;s. In the last post, all peripheral manipulation was achieved through seemingly random volatile writes at given addresses; of course this still needs to happen, but do we need to care about the address and bitshift values? svd2rust hides all of that behind a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;svd2rust&#x2F;0.17.0&#x2F;svd2rust&#x2F;&quot;&gt;simple, well documented API&lt;&#x2F;a&gt; which makes developing higher level abstractions far simpler. For example, disabling the rtc watchdog looks like this: 
&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;disable_rtc_wdt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rtccntl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;esp32::RTCCNTL) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Disables write protection *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;
    rtccntl.wdtwprotect.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{ w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;WDT_WKEY_VALUE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) });
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Disables all wdt stages &amp;amp; the global watchdog flag itself *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;
    rtccntl.wdtconfig0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        w
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_flashboot_mod_en&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_en&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
    });
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Re-enables write protection *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;
    rtccntl.wdtwprotect.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{ w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) });
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Not a single address or bitshift in sight!&lt;&#x2F;p&gt;
&lt;p&gt;To generate the initial SVD, the data has to come from somewhere. Intially @jeandudey put together an SVD including just the GPIO peripheral, but &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;pull&#x2F;2#issuecomment-565825098&quot;&gt;this approach would be a lot of work&lt;&#x2F;a&gt; to generate info for the entire chip. I decided to explore parsing the info from the esp-idf (Espressif&#x27;s C based HAL&#x2F;libs) code documentation, hence &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; was born; it does a pretty good job of scraping 95%~ of the data we need but &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&#x2F;issues&quot;&gt;there are still a few things&lt;&#x2F;a&gt; that could be improved.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately a lot of the issues with the generated data can be fixed with the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&#x2F;svdtools&quot;&gt;svd patching tool&lt;&#x2F;a&gt;, there have already been a few PR&#x27;s to fix missing peripherals that idf2svd &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32&#x2F;pull&#x2F;8&quot;&gt;missed&lt;&#x2F;a&gt; or &lt;a href=&quot;(https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32&#x2F;pull&#x2F;7)&quot;&gt;clean up register&lt;&#x2F;a&gt; and bitfield names. Any PR&#x27;s to clean up the SVD are very welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bonus-using-cortex-m-debug-with-the-esp32&quot;&gt;Bonus: Using cortex-m debug with the ESP32&lt;&#x2F;h2&gt;
&lt;p&gt;A side effect of creating the SVD file for svd2rust is that we can now use that SVD file in other applications. The arm developers among you may have heard of an vscode extension called &lt;a href=&quot;https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=marus25.cortex-debug&quot;&gt;cortex-m debug&lt;&#x2F;a&gt;, on top of GDB debugging, it provides really nice info about the state of the registers and peripherals; it does this by, yep you guessed it, using the SVD files that cortex-m silicon vendors provide.&lt;&#x2F;p&gt;
&lt;p&gt;Getting it running with the ESP32 is actually pretty simple; instead of using the arm gdb we will be using &lt;code&gt;xtensa-esp32-elf-gdb&lt;&#x2F;code&gt; which we can get from downloading the &lt;a href=&quot;https:&#x2F;&#x2F;docs.espressif.com&#x2F;projects&#x2F;esp-idf&#x2F;en&#x2F;stable&#x2F;get-started&#x2F;index.html#setup-toolchain&quot;&gt;xtensa toolchain&lt;&#x2F;a&gt; from Espressif, along with their &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;openocd-esp32&quot;&gt;openocd server&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;configuration&quot;&gt;Configuration&lt;&#x2F;h3&gt;
&lt;p&gt;Here is the example configuration taken from &lt;code&gt;xtensa-rust-quickstart&lt;&#x2F;code&gt;; its important to note that cortex-m debug expects the toolchain&#x27;s gdb to be called &lt;code&gt;arm-non-eabi-gdb&lt;&#x2F;code&gt; hence, where ever you specify the toolchain path there must be a file called &lt;code&gt;arm-none-eabi-gdb&lt;&#x2F;code&gt; else it won&#x27;t work. I chose to just symlink &lt;code&gt;xtensa-esp32-elf-gdb&lt;&#x2F;code&gt; to &lt;code&gt;arm-none-eabi-gdb&lt;&#x2F;code&gt; inside that directory.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; the config inside launch.json
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cwd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${workspaceRoot}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;executable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;target&#x2F;xtensa-esp32-none-elf&#x2F;debug&#x2F;esp32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;debug-with-svd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;request&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;attach&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cortex-debug&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;servertype&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openocd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;interface&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;jtag&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Download this from the latest &#96;esp32&#96; crate: https:&#x2F;&#x2F;docs.rs&#x2F;esp32&#x2F;latest&#x2F;esp32&#x2F; *&#x2F;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;svdFile&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;svd&#x2F;esp32.svd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; complains about not allowed,
    &#x2F;&#x2F; but it does work.. https:&#x2F;&#x2F;github.com&#x2F;Marus&#x2F;cortex-debug&#x2F;issues&#x2F;111#issuecomment-504778053
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;serverpath&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${env:HOME}&#x2F;programs&#x2F;openocd-esp32&#x2F;bin&#x2F;openocd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; for this to work you will have to run &#96;ln -s xtensa-esp32-elf-gdb arm-none-eabi-gdb&#96;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;toolchainPath&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${env:HOME}&#x2F;programs&#x2F;xtensa-esp32-elf&#x2F;bin&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;configFiles&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: [
        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openocd.cfg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
    ],
},
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;debug-with-svd.png&quot;&#x2F;&gt;
It even shows you the processor register values!
&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;xtensa-reg-display.png&quot;&#x2F;&gt;
&lt;p&gt;The best part about this approach is that it&#x27;s language &amp;amp; framework agnostic, meaning if you use the esp-idf, the arduino core or anything else you can still use the SVD even if your not using Rust. Like I said earlier the SVD is still a little rough around the edges, so patches are very welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next&lt;&#x2F;h2&gt;
&lt;p&gt;At the time of writing the Espressif have just released there third iteration of their llvm fork, so I will be spending a lot of time building and updating the forks and libraries to support that. The new fork should also fix some long standing and annoying bugs outlined in my first post. Expect another post soon if thats the case!&lt;&#x2F;p&gt;
&lt;p&gt;Finally, if you appreciate the effort going into this project, &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;mabezdev&quot;&gt;consider sponsoring me on Github&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;xtensa-quickstart&lt;&#x2F;a&gt; - A quickstart project for using Rust on xtensa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&quot;&gt;rust-xtensa&lt;&#x2F;a&gt; - The xtensa fork of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&quot;&gt;esp-rs&lt;&#x2F;a&gt; - The &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organization&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&quot;&gt;github&lt;&#x2F;a&gt; - My github&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
            </item>
        
    </channel>
</rss>
