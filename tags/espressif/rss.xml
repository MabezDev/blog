<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Scott Mabin</title>
        <link>https%3A//mabez.dev</link>
        <description>Scott Mabin&#x27;s blog</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https%3A//mabez.dev/tags/espressif/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Mon, 18 Oct 2021 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Rust on Espressif chips - 18-10-2021</title>
                <pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp-rust-18-10-2021/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp-rust-18-10-2021/</guid>
                <description>&lt;p&gt;Now I am working at Espressif I plan on publishing updates roughly every quarter just to keep the community in the loop around the esp rust effort.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;documentation-planning&quot;&gt;Documentation &amp;amp; Planning&lt;&#x2F;h2&gt;
&lt;p&gt;One of the hardest parts in any community project is onboarding new developers, especially in the early stages of a project where API&#x27;s, processes and tooling is changing rapidly; it can be frustrating to work on something one week, and in the next you&#x27;re fighting to get it compiling again. We began work on &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;a book&lt;&#x2F;a&gt; in which we will try to keep as a source of truth for the Rust esp effort. This will include install instructions, tooling guides, ecosystem overviews and much more. &lt;&#x2F;p&gt;
&lt;p&gt;We have also put together a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;esp-rs&#x2F;projects&#x2F;1&quot;&gt;road map project&lt;&#x2F;a&gt; on github, with the aim of managing the project from Espressif&#x27;s point of view, but also to allow new contributors to pick up backlog items. Simply comment in the issue if there is something you&#x27;d like to take a stab at, we&#x27;re more than happy to assist and review. We also host bi-weekly meetings which anyone is welcome to attend, just drop a comment &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;discussions&quot;&gt;in the latest discussion thread&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-the-rust-standard-library-on-espressif-chips&quot;&gt;Using the Rust standard library on Espressif chips&lt;&#x2F;h2&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp-rust-espressif&#x2F;&quot;&gt;the last post&lt;&#x2F;a&gt;, I mentioned that was possible to use the Rust standard library thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt;&#x27;s hard work; well, he&#x27;s been at it again! He pushed forward and managed to upstream the standard library changes required to build &lt;code&gt;std&lt;&#x2F;code&gt; on top of &lt;code&gt;esp-idf&lt;&#x2F;code&gt;. From Rust 1.56 it the changes will be stable, meaning it&#x27;s possible to use the upstream Rust toolchain to build the &lt;code&gt;std&lt;&#x2F;code&gt; platform for any RISC-V Espressif chip! Currently, that only includes the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; but there are more to come. This change also applies to Xtensa chips, however they still require a custom toolchain due to the lack of a backend for Xtensa in upstream LLVM. For more info in the &lt;code&gt;std&lt;&#x2F;code&gt; effort, please see &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;the book&lt;&#x2F;a&gt;. I&#x27;d also like to take this time to thank the upstream Rust developers for the prompt and helpful reviews, in particular &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Amanieu&quot;&gt;@Amanieu&lt;&#x2F;a&gt; for helping us push this over the finish line.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;compiler&quot;&gt;Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;The custom toolchain is a hindrance to developer onboarding, especially if developers have to build it themselves. We now offer a prebuilt toolchain&#x27;s for all common OS&#x27;s under the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust-build&quot;&gt;esp-rs&#x2F;rust-build&lt;&#x2F;a&gt; repository. A few days after a new Rust release we typically have the new compiler ready, unless we run into any issues; speaking of, we now test the compiler with a few projects in CI so hopefully we don&#x27;t ship a broken compiler. Note that this extra compiler step is only required when targeting Espressif&#x27;s Xtensa based chips.&lt;&#x2F;p&gt;
&lt;p&gt;There have been a couple of improvements to the compiler fork since the last post, for one the patch set we have to manage has reduced in size thanks to the &lt;code&gt;std&lt;&#x2F;code&gt; library changes being upstreamed. There is now &lt;code&gt;asm!&lt;&#x2F;code&gt; support for the Xtensa architecture, which also means we have removed the old &lt;code&gt;llvm_asm!&lt;&#x2F;code&gt; macros from the &lt;code&gt;xtensa&lt;&#x2F;code&gt; crates and ported them to the new syntax.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;svds&quot;&gt;SVDs&lt;&#x2F;h3&gt;
&lt;p&gt;SVDs have been coming along very nicely, we now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;svd&#x2F;tree&#x2F;main&#x2F;svd&quot;&gt;have official SVDs&lt;&#x2F;a&gt; for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, &lt;code&gt;esp32s2&lt;&#x2F;code&gt; and the &lt;code&gt;esp32&lt;&#x2F;code&gt;. If you have been following this effort for a while, you may be thinking we already had an &lt;code&gt;esp32&lt;&#x2F;code&gt; SVD, well you would be correct! However, it was very hacky, missed a lot of peripherals and was all around horrible to work with. The new SVD aims to be more complete and importantly more consistent. One thing that has been missing from the official SVDs is interrupt information, however this has recently changed and interrupt information for each peripheral is now available. Overall the SVDs available now are in a great spot to feed into &lt;code&gt;svd2rust&lt;&#x2F;code&gt; and other tooling, ready for HAL creation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;espflash&quot;&gt;&lt;code&gt;espflash&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&quot;&gt;&lt;code&gt;espflash&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a rewrite of Espressif&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esptool&quot;&gt;&lt;code&gt;esptool.py&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, but also has &lt;code&gt;cargo&lt;&#x2F;code&gt; integration. It&#x27;s been under heavy development and now has a &lt;code&gt;1.0&lt;&#x2F;code&gt; release! Including:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Support for flashing:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;esp32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp32c3&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp32s2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp8266&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Compression for faster flashing.&lt;&#x2F;li&gt;
&lt;li&gt;Support for the &lt;code&gt;esp-idf&lt;&#x2F;code&gt; partition table format.&lt;&#x2F;li&gt;
&lt;li&gt;Support for flashing a stock &lt;code&gt;esp-idf&lt;&#x2F;code&gt; bootloader.&lt;&#x2F;li&gt;
&lt;li&gt;Removed support &lt;code&gt;xargo&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;cargo xbuild&lt;&#x2F;code&gt;, now focusing support on &lt;code&gt;build-std&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Reading back flash info.&lt;&#x2F;li&gt;
&lt;li&gt;Reading some EFUSE values.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;elf2image&lt;&#x2F;code&gt; functionality, for writing the formatted image to a file.&lt;&#x2F;li&gt;
&lt;li&gt;Beautiful &amp;amp; helpful error messages with &lt;code&gt;miette&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Big thanks to all the contributors in this release, especially &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;probe-rs&quot;&gt;&lt;code&gt;probe-rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;We have also started adding support for flashing and debugging Espressif chips with &lt;code&gt;probe-rs&lt;&#x2F;code&gt;. As the RISC-V architecture is already supported in &lt;code&gt;probe-rs&lt;&#x2F;code&gt;, we set out to add support for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; initially. We are happy to report that &lt;code&gt;probe-rs&lt;&#x2F;code&gt; master now has a flash algorithm capable of flashing the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;! The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-flash-loader&quot;&gt;&lt;code&gt;esp-flash-loader&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; repository contains the code for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; flash loader, but thanks for Espressif&#x27;s ROM API it should be very easy to port the algorithm to the other chips. Xtensa support for &lt;code&gt;probe-rs&lt;&#x2F;code&gt; is planned eventually, but will take some time to implement. A big thank you to the &lt;code&gt;probe-rs&lt;&#x2F;code&gt; folks, in particular &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Yatekii&quot;&gt;@Yatekii&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Tiwalun&quot;&gt;@Tiwalun&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Dirbaio&quot;&gt;@Dirbaio&lt;&#x2F;a&gt; for the reviews and assistance.&lt;&#x2F;p&gt;
&lt;p&gt;Having &lt;code&gt;probe-rs&lt;&#x2F;code&gt; support gives us easy access to &lt;a href=&quot;https:&#x2F;&#x2F;www.segger.com&#x2F;products&#x2F;debug-probes&#x2F;j-link&#x2F;technology&#x2F;about-real-time-transfer&#x2F;&quot;&gt;RTT&lt;&#x2F;a&gt; for fast, low overhead logging. We have the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; using RTT with &lt;code&gt;probe-rs&lt;&#x2F;code&gt; locally, however a few patches are required due to the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;&#x27;s lack of atomics. Whilst we have contributed to crates such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;atomic-polyfill&#x2F;pull&#x2F;6&quot;&gt;atomic-polyfill&lt;&#x2F;a&gt; these crates are quite intrusive and require other ecosystem crates to depend on them instead of &lt;code&gt;core::sync::atomic&lt;&#x2F;code&gt;. To combat this, we are in the process of writing an atomic emulation trap handler. This works by treating the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; like it has atomic support (build as &lt;code&gt;riscv32imac-unknown-none-elf&lt;&#x2F;code&gt;), and when we trap on the atomic instructions, we decode them and emulate them in software transparently. There is a performance penalty that it is roughly 2-4x slower than native instructions based on our testing, but having an atomic story is important in the embedded Rust ecosystem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Continue to improve the tooling around Rust with Espressif chips, until we have out of the box solutions for most stories. Continue to build and polish standard library use with Espressif chips, as well as the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; story. We would also like to explore using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustc_codegen_gcc&quot;&gt;rustc_codegen_gcc&lt;&#x2F;a&gt; to try and target Espressif&#x27;s Xtensa chips. The end goal will still be to upstream the Xtensa backend to LLVM, but &lt;code&gt;rustc_codegen_gcc&lt;&#x2F;code&gt; may allow targeting Xtensa chips faster as GCC already has a stable Xtensa backend. &lt;&#x2F;p&gt;
&lt;p&gt;Expect another update early next year!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Rust on Espressif chips</title>
                <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp-rust-espressif/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp-rust-espressif/</guid>
                <description>&lt;p&gt;It&#x27;s been a while since my last post. I have some exciting news to share before going over the progress over the last nine months. I will be joining Espressif full time to work on Rust support for all of Espressif&#x27;s chips, past, present and future! I am very excited to join Espressif and improve the Rust ecosystem surrounding their chips!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;organisation&quot;&gt;Organisation&lt;&#x2F;h3&gt;
&lt;p&gt;The forked compiler with esp support has been moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organisation, along with some idf support crates - more on that shortly! &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;discussions&quot;&gt;Discussions&lt;&#x2F;a&gt; have been enabled on the &lt;code&gt;esp-rs&#x2F;rust&lt;&#x2F;code&gt; repository, and for the last month Espressif have been hosting weekly community meetings focusing on pushing Rust support forward. If you&#x27;d like to discuss something and attend, drop a comment in the latest thread and request an invite!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-rust-standard-library-on-espressif-chips&quot;&gt;The Rust standard library on Espressif chips&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; been working very hard on porting the Rust STD library to &lt;code&gt;esp-idf&lt;&#x2F;code&gt;, the C based development environment for Espressif chips. &lt;code&gt;esp-idf&lt;&#x2F;code&gt; has a newlib environment which can be used to build the Rust library on top of. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; has put together &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;rust-esp32-std-hello&quot;&gt;rust-esp32-std-hello&lt;&#x2F;a&gt; demo repo to show off the capabilities, which include WiFi, threads and driving a display using the &lt;code&gt;esp-idf&lt;&#x2F;code&gt;&#x27;s drivers. Extremely cool stuff! There are a few teething issues, which you can track &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;57&quot;&gt;here&lt;&#x2F;a&gt; but hopefully we will be in a position to start upstreaming these patches soon.&lt;&#x2F;p&gt;
&lt;p&gt;To suppliment the standard library for Espressif chips, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&quot;&gt;&lt;code&gt;esp-idf-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has been updated and moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organisation. This crate has API&#x27;s to use peripherals and hardware that do not have abstractions in the standard library, for example the SPI peripheral. Along with the HAL, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-svc&quot;&gt;&lt;code&gt;esp-idf-svc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has also been added, which is an implementation of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;embedded-svc&quot;&gt;&lt;code&gt;embedded-svc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; traits for Espressif chips. The goal behind &lt;code&gt;embedded-svc&lt;&#x2F;code&gt; is to provide abstractions around higher level embedded services, WiFi, Ping, HTTPD, NVS etc.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bare-metal&quot;&gt;Bare metal&lt;&#x2F;h3&gt;
&lt;p&gt;Whilst the biggest changes have been around esp standard library developments, bare metal support has not been forgotten! A few months I got my hands on a &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, a &lt;code&gt;RISC-V&lt;&#x2F;code&gt; based chip; because upstream Rust already supports &lt;code&gt;RISC-V&lt;&#x2F;code&gt; putting together a rudimentary bare metal example was &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;esp32c3-experiments&quot;&gt;quite simple&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Blinky program written in &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;rustlang?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#rustlang&lt;&#x2F;a&gt;, running on the RISC-V powered &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;esp32c3?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#esp32c3&lt;&#x2F;a&gt; from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;espressif?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#espressif&lt;&#x2F;a&gt; . &lt;a href=&quot;https:&#x2F;&#x2F;t.co&#x2F;9qfqZk1WYq&quot;&gt;pic.twitter.com&#x2F;9qfqZk1WYq&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&amp;mdash; Scott Mabin (@mabezzzzz) &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;mabezzzzz&#x2F;status&#x2F;1391500605915607049?ref_src=twsrc%5Etfw&quot;&gt;May 9, 2021&lt;&#x2F;a&gt;&lt;&#x2F;blockquote&gt; &lt;script async src=&quot;https:&#x2F;&#x2F;platform.twitter.com&#x2F;widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Whilst the program above worked, much like &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust&#x2F;&quot;&gt;my first ever post&lt;&#x2F;a&gt; it isn&#x27;t very &amp;quot;Rusty&amp;quot;. Fortunately Espressif have recently release &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;svd&#x2F;tree&#x2F;esp32c3&quot;&gt;a preliminary SVD file for the esp32c3&lt;&#x2F;a&gt;, the first of its kind from Espressif which is super exciting! This means we can feed the SVD into &lt;code&gt;svd2rust&lt;&#x2F;code&gt; (see my other post about doing this for the esp32 &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;) and generate a peripheral access crate (PAC) for the esp32c3 and build abstractions on top of that. With official SVD&#x27;s coming out I hope that we can integrate that into the current bare metal &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&quot;&gt;&lt;code&gt;esp32-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, turning it into a mono repository supporting all of Espressif&#x27;s chips in pure Rust.&lt;&#x2F;p&gt;
&lt;p&gt;It also means I can finally kill off the abomination which is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;&lt;code&gt;idf2svd&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; :D.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h3&gt;
&lt;p&gt;We should be able to start upstreaming some of the RISC-V based changes soon! With official SVD&#x27;s coming out, bare metal esp32 support should start moving forward again too.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
