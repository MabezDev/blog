<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Scott Mabin</title>
        <link>https%3A//mabez.dev</link>
        <description>Scott Mabin&#x27;s blog</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https%3A//mabez.dev/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 28 Jul 2021 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Rust on Espressif&#x27;s chips</title>
                <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp-rust-espressif/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp-rust-espressif/</guid>
                <description>&lt;p&gt;It&#x27;s been a while since my last post. I have some exciting news to share before going over the progress over the last nine months. I will be joining Espressif full time to work on Rust support for all of Espressif&#x27;s chips, past, present and future! I am very excited to join Espressif and improve the Rust ecosystem surrounding their chips!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;organisation&quot;&gt;Organisation&lt;&#x2F;h3&gt;
&lt;p&gt;The forked compiler with esp support has been moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organisation, along with some idf support crates - more on that shortly! &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;discussions&quot;&gt;Discussions&lt;&#x2F;a&gt; have been enabled on the &lt;code&gt;esp-rs&#x2F;rust&lt;&#x2F;code&gt; repository, and for the last month Espressif have been hosting weekly community meetings focusing on pushing Rust support forward. If you&#x27;d like to discuss something and attend, drop a comment in the latest thread and request an invite!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-rust-standard-library-on-espressif-chips&quot;&gt;The Rust standard library on Espressif chips&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; been working very hard on porting the Rust STD library to &lt;code&gt;esp-idf&lt;&#x2F;code&gt;, the C based development environment for Espressif chips. &lt;code&gt;esp-idf&lt;&#x2F;code&gt; has a newlib environment which can be used to build the Rust library on top of. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; has put together &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;rust-esp32-std-hello&quot;&gt;rust-esp32-std-hello&lt;&#x2F;a&gt; demo repo to show off the capabilities, which include WiFi, threads and driving a display using the &lt;code&gt;esp-idf&lt;&#x2F;code&gt;&#x27;s drivers. Extremely cool stuff! There are a few teething issues, which you can track &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;57&quot;&gt;here&lt;&#x2F;a&gt; but hopefully we will be in a position to start upstreaming these patches soon.&lt;&#x2F;p&gt;
&lt;p&gt;To suppliment the standard library for Espressif chips, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&quot;&gt;&lt;code&gt;esp-idf-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has been updated and moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organisation. This crate has API&#x27;s to use peripherals and hardware that do not have abstractions in the standard library, for example the SPI peripheral. Along with the HAL, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-svc&quot;&gt;&lt;code&gt;esp-idf-svc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has also been added, which is an implementation of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;embedded-svc&quot;&gt;&lt;code&gt;embedded-svc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; traits for Espressif chips. The goal behind &lt;code&gt;embedded-svc&lt;&#x2F;code&gt; is to provide abstractions around higher level embedded services, WiFi, Ping, HTTPD, NVS etc.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bare-metal&quot;&gt;Bare metal&lt;&#x2F;h3&gt;
&lt;p&gt;Whilst the biggest changes have been around esp standard library developments, bare metal support has not been forgotten! A few months I got my hands on a &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, a &lt;code&gt;RISC-V&lt;&#x2F;code&gt; based chip; because upstream Rust already supports &lt;code&gt;RISC-V&lt;&#x2F;code&gt; putting together a rudimentary bare metal example was &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;esp32c3-experiments&quot;&gt;quite simple&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Blinky program written in &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;rustlang?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#rustlang&lt;&#x2F;a&gt;, running on the RISC-V powered &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;esp32c3?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#esp32c3&lt;&#x2F;a&gt; from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;espressif?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#espressif&lt;&#x2F;a&gt; . &lt;a href=&quot;https:&#x2F;&#x2F;t.co&#x2F;9qfqZk1WYq&quot;&gt;pic.twitter.com&#x2F;9qfqZk1WYq&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&amp;mdash; Scott Mabin (@mabezzzzz) &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;mabezzzzz&#x2F;status&#x2F;1391500605915607049?ref_src=twsrc%5Etfw&quot;&gt;May 9, 2021&lt;&#x2F;a&gt;&lt;&#x2F;blockquote&gt; &lt;script async src=&quot;https:&#x2F;&#x2F;platform.twitter.com&#x2F;widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Whilst the program above worked, much like &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust&#x2F;&quot;&gt;my first ever post&lt;&#x2F;a&gt; it isn&#x27;t very &amp;quot;Rusty&amp;quot;. Fortunately Espressif have recently release &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;svd&#x2F;tree&#x2F;esp32c3&quot;&gt;a preliminary SVD file for the esp32c3&lt;&#x2F;a&gt;, the first of its kind from Espressif which is super exciting! This means we can feed the SVD into &lt;code&gt;svd2rust&lt;&#x2F;code&gt; (see my other post about doing this for the esp32 &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;) and generate a peripheral access crate (PAC) for the esp32c3 and build abstractions on top of that. With official SVD&#x27;s coming out I hope that we can integrate that into the current bare metal &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&quot;&gt;&lt;code&gt;esp32-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, turning it into a mono repository supporting all of Espressif&#x27;s chips in pure Rust.&lt;&#x2F;p&gt;
&lt;p&gt;It also means I can finally kill off the abomination which is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;&lt;code&gt;idf2svd&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; :D.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h3&gt;
&lt;p&gt;We should be able to start upstreaming some of the RISC-V based changes soon! With official SVD&#x27;s coming out, bare metal esp32 support should start moving forward again too.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Rust on the ESP32 &amp; ESP8266 - Building an ecosystem</title>
                <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp-rust-ecosystem/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp-rust-ecosystem/</guid>
                <description>&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;last post, nearly 10 months ago&lt;&#x2F;a&gt; a lot has changed. For one, its not just me working on this any more! Community members are starting to contribute to the various ESP related projects. The extra help meant we have made considerable progress which I will now take you through in this post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-compiler&quot;&gt;The compiler&lt;&#x2F;h2&gt;
&lt;p&gt;I have been working on cleaning up the &lt;code&gt;rustc&lt;&#x2F;code&gt; work, including rebasing regularly to keep up with upstream rustc changes. Recently, I have cleaned up and extracted the patches required to enable &lt;code&gt;Xtensa&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp&lt;&#x2F;code&gt; development with Rust, firstly to make it easier to rebase onto a newer version of the compiler, but also in the hopes of one day being able to submit these patches upstream when the &lt;code&gt;Xtensa&lt;&#x2F;code&gt; target is upstreamed in llvm. You can see the patchset &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa-patches&quot;&gt;here&lt;&#x2F;a&gt;. On that note, it seems no progress has been made on that front in the last 9 months; whilst Espressif are doing a great job responding to issues and fixing bugs, it seems the patches are stuck in review in llvm. I&#x27;m unsure what directions to take to get more attention to this. &lt;&#x2F;p&gt;
&lt;p&gt;I have also reworked the build process, as well as tagging releases. It is no longer necessary to build LLVM seperately, as I have swapped out the LLVM submodule to the forked one, meaning you can just use normal rust build instructions. Starting now, I will also be tagging releases every time I rebase on upstream master; on top of which I am also offering prebuilt linux (sorry Windows &amp;amp; Mac users) toolchains on the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&#x2F;releases&#x2F;tag&#x2F;xtensa-v0.2.0&quot;&gt;releases&lt;&#x2F;a&gt; (if you are building for Mac or Windows, please feel free to send me your prebuilt toolchains for upload).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling-improvements&quot;&gt;Tooling improvements&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cargo-espflash&quot;&gt;cargo-espflash&lt;&#x2F;h3&gt;
&lt;p&gt;For those of you not familiar with developing on ESP* platforms, there is a flashing tool &lt;code&gt;esptool.py&lt;&#x2F;code&gt; which will flash your program to the device. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; began rewriting this tool in Rust, called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&quot;&gt;espflash&lt;&#x2F;a&gt;. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; then submitted &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;1&quot;&gt;a PR which added a cargo interface&lt;&#x2F;a&gt; to it, meaning we can easily build and flash all in one go, for example building and flashing the blinky example in the ESP32 HAL:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; cargo espflash&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --chip&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; esp32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --example&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; blinky &#x2F;dev&#x2F;ttyUSB0
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s really nice to invoke cargo once, make a coffee, and have your code running on the board when you get back! We&#x27;ve been adding more features to the tool, like reading back board info (flash size, CPU revision etc) in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;3&quot;&gt;#3&lt;&#x2F;a&gt;, and allowing faster flash speeds for the ESP32 in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;5&quot;&gt;#5&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;idf2svd&quot;&gt;idf2svd&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; submitted a PR to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; to add support for generating ESP8266 SVD&#x27;s, of which the esp8266-hal is built upon; &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;if you remeber back to the bonus section of my last post&lt;&#x2F;a&gt;, you will be able to use that SVD to debug ESP8266 applications too!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-runtime-crates&quot;&gt;The runtime crates&lt;&#x2F;h2&gt;
&lt;p&gt;After my last post I set to improve the runtime crate to include support for exceptions, which &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx6-rt&#x2F;pull&#x2F;6&quot;&gt;I started before&lt;&#x2F;a&gt; taking a short break. In that time &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt; championed it, fully implementing exception and interrupt handling for the lx6 CPU of the ESP32! On top of that, for those of you familiar with the &lt;code&gt;cortex-m-rt&lt;&#x2F;code&gt; crates, we implemented the attribute macros for defining &lt;code&gt;#[interrupt]&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;#[exception]&lt;&#x2F;code&gt; handlers and the &lt;code&gt;#[entry]&lt;&#x2F;code&gt; point to the program. Previously &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx6&quot;&gt;&lt;code&gt;xtensa-lx6&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; was empty, but we have since implemented (and moved code from rt where neccessary), including the on chip &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;xtensa-lx6&#x2F;0.2.0&#x2F;xtensa_lx6&#x2F;timer&#x2F;index.html&quot;&gt;timers&lt;&#x2F;a&gt; and a series of &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;xtensa-lx6&#x2F;0.2.0&#x2F;xtensa_lx6&#x2F;mutex&#x2F;index.html&quot;&gt;mutex&lt;&#x2F;a&gt; implementations for the platform.&lt;&#x2F;p&gt;
&lt;p&gt;Meanwhile &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; began writing a runtime crate for the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&#x2F;xtensa-lx106-rt&quot;&gt;lx106&lt;&#x2F;a&gt;, the processor in a ESP8266. We found that between the &lt;code&gt;xtensa-lx&lt;&#x2F;code&gt; series there were not many differences, confirming what a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx-rt&#x2F;issues&#x2F;5#issuecomment-578419057&quot;&gt;core esp-idf developer mentioned&lt;&#x2F;a&gt; previously, therefore we decided to merge the lx6 and lx106 crates producing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx&quot;&gt;&lt;code&gt;xtensa-lx&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx-rt&quot;&gt;&lt;code&gt;xtensa-lx-rt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with features for each silicon revision.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-hal-crates&quot;&gt;The HAL crates&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;esp32&quot;&gt;ESP32&lt;&#x2F;h3&gt;
&lt;p&gt;With the runtime crates in good shape, we now had a good basis to build a HAL (Hardware abstraction layer). I started by submitting a simple &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;commit&#x2F;8a3f2e750335623b551d59419e4e138659cc77aa&quot;&gt;GPIO driver for the ESP32&lt;&#x2F;a&gt; implementing the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;embedded-hal&quot;&gt;embedded-hal digital traits&lt;&#x2F;a&gt;. Since then the features haven&#x27;t stopped coming, primarily thanks once again to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt;. Checkout &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;tree&#x2F;master&#x2F;examples&quot;&gt;the examples&lt;&#x2F;a&gt; to see what you can do with an ESP32 in pure Rust&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#pure-rust&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;! &lt;&#x2F;p&gt;
&lt;h3 id=&quot;esp8266&quot;&gt;ESP8266&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; has since started the ESP8266 HAL. One thing that is slowing down development is the fact that alot of the functions in the C SDK are simply binary blobs (or as Espressif refer to them, ROM functions). It means that re-implementing them in Rust requires disassembly  of the binaries and reverse engineering of the assembly to figure out whats going on. Whilst it is undoubtedly fun, it is a lot harder than looking at the source (which we can do with the ESP32). It&#x27;s coming along nicely though, with support for GPIO, Serial, SPI and much more. Checkout the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp8266-hal&quot;&gt;esp-rs&#x2F;esp8266-hal&lt;&#x2F;a&gt; repo. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; has started a BSP (board support package) for the D1 Mini ESP8266 board, built on top of the esp8266-hal, so if you have one of those board lying around check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&#x2F;d1-mini&quot;&gt;repo&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-quickstart&quot;&gt;The quickstart&lt;&#x2F;h2&gt;
&lt;p&gt;With the compiler changes and HAL&#x27;s being created, the old quickstart needed some love. First on the list removing some unneeded compiler restrictions, mainly around allowing debug info generation, as the LLVM fork now supports that (See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;23&quot;&gt;#23&lt;&#x2F;a&gt;). The biggest change has been adding runnable examples for both the ESP32 &amp;amp; ESP8266; its now easier than ever to Rustup your Esp microcontroller! I have also added &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;blob&#x2F;04f9fb79e9a6a519a3311bc1e5a5e22af7c93f29&#x2F;src&#x2F;main.rs#L1-L55&quot;&gt;a brief overview&lt;&#x2F;a&gt; of how to target a different Xtensa target other than the ESP32 or ESP8266, though I&#x27;m not aware of any other boards using this architecture, would be very interested to hear about it if you are aware of any.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;I&#x27;d love to see more contributors as it&#x27;s easier than ever to contribute if you are familiar with Rust or embedded; both HAL&#x27;s are in a good spot to pick a hardware feature and implement it in Rust! &lt;&#x2F;li&gt;
&lt;li&gt;Myself and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt; are looking &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-wifi&quot;&gt;at WiFi&#x2F;Bluetooth support&lt;&#x2F;a&gt; for the ESP32, but haven&#x27;t had much luck so far. &lt;&#x2F;li&gt;
&lt;li&gt;At some point I&#x27;d like to start looking into integrating with an existing Rust RTOS, perhaps &lt;a href=&quot;https:&#x2F;&#x2F;www.tockos.org&#x2F;&quot;&gt;tockos&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;rtic.rs&#x2F;0.5&#x2F;book&#x2F;en&#x2F;&quot;&gt;rtic&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;At this point I&#x27;d like to say a big thank you to all the contributors who have helped along the way so far!&lt;&#x2F;p&gt;
&lt;p&gt;Finally, if you appreciate the effort going into this, consider joining @davidkern, @DaMouse404 and others &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;mabezdev&quot;&gt;in sponsoring me&lt;&#x2F;a&gt;, it&#x27;s very much appreciated &amp;lt;3.&lt;&#x2F;p&gt;
&lt;iframe src=&quot;https:&#x2F;&#x2F;github.com&#x2F;sponsors&#x2F;MabezDev&#x2F;card&quot; title=&quot;Sponsor MabezDev&quot; height=&quot;225&quot; width=&quot;600&quot; style=&quot;border: 0;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;br&gt;
&lt;hr &#x2F;&gt;
&lt;br&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;pure-rust&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Not quite! We&#x27;re still using the C bootloader to initialize the flash for now. Note that you can run applications entirely in RAM if you wish.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Rust on the ESP32 - SVD&#x27;s, PAC&#x27;s and USB flashing</title>
                <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp32-rust-svd-pac/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp32-rust-svd-pac/</guid>
                <description>&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust&#x2F;&quot;&gt;last post&lt;&#x2F;a&gt; I&#x27;ve been working on building the humble beginnings of an ecosystem around the ESP32 for Rust. The short version of this post is as follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;4&quot;&gt;This PR&lt;&#x2F;a&gt; means the quickstart repo can now flash and run code without a debugger! Simply using the &lt;code&gt;flash&lt;&#x2F;code&gt; or &lt;code&gt;flash_release&lt;&#x2F;code&gt; scripts will flash your code and begin running your code&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; has been created which uses the documentation from &lt;code&gt;esp-idf&lt;&#x2F;code&gt; to generate svd files fit for consumption by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;svd2rust&quot;&gt;svd2rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Based on the generated SVD file, there is now a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;esp32&#x2F;latest&#x2F;esp32&#x2F;&quot;&gt;PAC (Peripheral access crate)&lt;&#x2F;a&gt; for the ESP32.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fixing-xtensa-rust-quickstart&quot;&gt;Fixing &lt;code&gt;xtensa-rust-quickstart&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As noted in my previous post, running Rust applications on the ESP32 required the use of a JTAG debugger as the board would reset repeatedly. My suspicion was a watch dog reset, but my &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;4&#x2F;commits&#x2F;d8d6971285d20aacb6db32a68138c58a77fa9efa&quot;&gt;initial experiments on disabling the watchdog&lt;&#x2F;a&gt; did not appear to be working. I decided to inspect the openocd source to see what the debugger does when it connects, it turns out that the ESP32 has another 2 timer based watch dogs as seen &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;openocd-esp32&#x2F;blob&#x2F;97ba3a6bb9eaa898d91df923bbedddfeaaaf28c9&#x2F;src&#x2F;target&#x2F;esp32.c#L431&quot;&gt;being disabled by openocd here&lt;&#x2F;a&gt;; after disabling those two watchdogs, its was possible to flash and run code with just the USB cable connected!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-the-esp32-peripheral-access-crate&quot;&gt;Creating the &lt;code&gt;esp32&lt;&#x2F;code&gt; peripheral access crate&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;http:&#x2F;&#x2F;www.keil.com&#x2F;pack&#x2F;doc&#x2F;CMSIS&#x2F;SVD&#x2F;html&#x2F;index.html&quot;&gt;SVD format&lt;&#x2F;a&gt; was created for ARM processors, but as it turns out it works very well for other processor architectures too. Espressif (unsuprisingly) don&#x27;t provide an SVD file, so I would have to create my own; but before I move on to that, what do we actually get from creating and SVD file for the ESP32? Well, it allows us to use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;svd2rust&quot;&gt;svd2rust&lt;&#x2F;a&gt; to generate really nice register access API&#x27;s. In the last post, all peripheral manipulation was achieved through seemingly random volatile writes at given addresses; of course this still needs to happen, but do we need to care about the address and bitshift values? svd2rust hides all of that behind a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;svd2rust&#x2F;0.17.0&#x2F;svd2rust&#x2F;&quot;&gt;simple, well documented API&lt;&#x2F;a&gt; which makes developing higher level abstractions far simpler. For example, disabling the rtc watchdog looks like this: 
&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;disable_rtc_wdt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rtccntl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;esp32::RTCCNTL) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Disables write protection *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;
    rtccntl.wdtwprotect.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{ w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;WDT_WKEY_VALUE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) });
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Disables all wdt stages &amp;amp; the global watchdog flag itself *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;
    rtccntl.wdtconfig0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        w
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_flashboot_mod_en&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_en&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
    });
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Re-enables write protection *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;
    rtccntl.wdtwprotect.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{ w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) });
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Not a single address or bitshift in sight!&lt;&#x2F;p&gt;
&lt;p&gt;To generate the initial SVD, the data has to come from somewhere. Intially @jeandudey put together an SVD including just the GPIO peripheral, but &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;pull&#x2F;2#issuecomment-565825098&quot;&gt;this approach would be a lot of work&lt;&#x2F;a&gt; to generate info for the entire chip. I decided to explore parsing the info from the esp-idf (Espressif&#x27;s C based HAL&#x2F;libs) code documentation, hence &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; was born; it does a pretty good job of scraping 95%~ of the data we need but &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&#x2F;issues&quot;&gt;there are still a few things&lt;&#x2F;a&gt; that could be improved.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately a lot of the issues with the generated data can be fixed with the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&#x2F;svdtools&quot;&gt;svd patching tool&lt;&#x2F;a&gt;, there have already been a few PR&#x27;s to fix missing peripherals that idf2svd &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32&#x2F;pull&#x2F;8&quot;&gt;missed&lt;&#x2F;a&gt; or &lt;a href=&quot;(https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32&#x2F;pull&#x2F;7)&quot;&gt;clean up register&lt;&#x2F;a&gt; and bitfield names. Any PR&#x27;s to clean up the SVD are very welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bonus-using-cortex-m-debug-with-the-esp32&quot;&gt;Bonus: Using cortex-m debug with the ESP32&lt;&#x2F;h2&gt;
&lt;p&gt;A side effect of creating the SVD file for svd2rust is that we can now use that SVD file in other applications. The arm developers among you may have heard of an vscode extension called &lt;a href=&quot;https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=marus25.cortex-debug&quot;&gt;cortex-m debug&lt;&#x2F;a&gt;, on top of GDB debugging, it provides really nice info about the state of the registers and peripherals; it does this by, yep you guessed it, using the SVD files that cortex-m silicon vendors provide.&lt;&#x2F;p&gt;
&lt;p&gt;Getting it running with the ESP32 is actually pretty simple; instead of using the arm gdb we will be using &lt;code&gt;xtensa-esp32-elf-gdb&lt;&#x2F;code&gt; which we can get from downloading the &lt;a href=&quot;https:&#x2F;&#x2F;docs.espressif.com&#x2F;projects&#x2F;esp-idf&#x2F;en&#x2F;stable&#x2F;get-started&#x2F;index.html#setup-toolchain&quot;&gt;xtensa toolchain&lt;&#x2F;a&gt; from Espressif, along with their &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;openocd-esp32&quot;&gt;openocd server&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;configuration&quot;&gt;Configuration&lt;&#x2F;h3&gt;
&lt;p&gt;Here is the example configuration taken from &lt;code&gt;xtensa-rust-quickstart&lt;&#x2F;code&gt;; its important to note that cortex-m debug expects the toolchain&#x27;s gdb to be called &lt;code&gt;arm-non-eabi-gdb&lt;&#x2F;code&gt; hence, where ever you specify the toolchain path there must be a file called &lt;code&gt;arm-none-eabi-gdb&lt;&#x2F;code&gt; else it won&#x27;t work. I chose to just symlink &lt;code&gt;xtensa-esp32-elf-gdb&lt;&#x2F;code&gt; to &lt;code&gt;arm-none-eabi-gdb&lt;&#x2F;code&gt; inside that directory.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; the config inside launch.json
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cwd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${workspaceRoot}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;executable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;target&#x2F;xtensa-esp32-none-elf&#x2F;debug&#x2F;esp32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;debug-with-svd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;request&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;attach&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cortex-debug&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;servertype&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openocd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;interface&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;jtag&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Download this from the latest &#96;esp32&#96; crate: https:&#x2F;&#x2F;docs.rs&#x2F;esp32&#x2F;latest&#x2F;esp32&#x2F; *&#x2F;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;svdFile&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;svd&#x2F;esp32.svd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; complains about not allowed,
    &#x2F;&#x2F; but it does work.. https:&#x2F;&#x2F;github.com&#x2F;Marus&#x2F;cortex-debug&#x2F;issues&#x2F;111#issuecomment-504778053
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;serverpath&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${env:HOME}&#x2F;programs&#x2F;openocd-esp32&#x2F;bin&#x2F;openocd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; for this to work you will have to run &#96;ln -s xtensa-esp32-elf-gdb arm-none-eabi-gdb&#96;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;toolchainPath&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${env:HOME}&#x2F;programs&#x2F;xtensa-esp32-elf&#x2F;bin&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;configFiles&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;: [
        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openocd.cfg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
    ],
},
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;debug-with-svd.png&quot;&#x2F;&gt;
It even shows you the processor register values!
&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;xtensa-reg-display.png&quot;&#x2F;&gt;
&lt;p&gt;The best part about this approach is that it&#x27;s language &amp;amp; framework agnostic, meaning if you use the esp-idf, the arduino core or anything else you can still use the SVD even if your not using Rust. Like I said earlier the SVD is still a little rough around the edges, so patches are very welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next&lt;&#x2F;h2&gt;
&lt;p&gt;At the time of writing the Espressif have just released there third iteration of their llvm fork, so I will be spending a lot of time building and updating the forks and libraries to support that. The new fork should also fix some long standing and annoying bugs outlined in my first post. Expect another post soon if thats the case!&lt;&#x2F;p&gt;
&lt;p&gt;Finally, if you appreciate the effort going into this project, &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;mabezdev&quot;&gt;consider sponsoring me on Github&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;xtensa-quickstart&lt;&#x2F;a&gt; - A quickstart project for using Rust on xtensa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&quot;&gt;rust-xtensa&lt;&#x2F;a&gt; - The xtensa fork of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&quot;&gt;esp-rs&lt;&#x2F;a&gt; - The &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organization&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&quot;&gt;github&lt;&#x2F;a&gt; - My github&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
            </item>
        
            <item>
                <title>Rust on the ESP32</title>
                <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
                <link>https%3A//mabez.dev/blog/posts/esp32-rust/</link>
                <guid>https%3A//mabez.dev/blog/posts/esp32-rust/</guid>
                <description>&lt;p&gt;About six months ago, I made a &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;ar2d3r&#x2F;espressif_have_finally_released_an_llvm_fork_this&#x2F;&quot;&gt;post on reddit&lt;&#x2F;a&gt; highlighting the launch of Espressif&#x27;s llvm xtensa fork, not too long after, I had a working &lt;code&gt;rustc&lt;&#x2F;code&gt; toolchain capable of generating xtensa assembly. At this point I had to put this project to the side to finish my final year of university. Funnily enough I didn&#x27;t stray too far, my final year project used Rust to create a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MWatch&quot;&gt;&#x27;smartwatch&#x27;&lt;&#x2F;a&gt; (I may write about this in the future, if anyone is interested). &lt;&#x2F;p&gt;
&lt;p&gt;Since then I have seen a few posts utilising my fork to run Rust on the &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;hardware&#x2F;esp32&#x2F;overview&quot;&gt;ESP32&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;dentrassi.de&#x2F;2019&#x2F;06&#x2F;16&#x2F;rust-on-the-esp-and-how-to-get-started&#x2F;&quot;&gt;see this great write up&lt;&#x2F;a&gt; by ctron, if you haven&#x27;t already), most of which are building on top of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-idf&quot;&gt;esp-idf&lt;&#x2F;a&gt; which is written in C. In this post I&#x27;ll be discussing the steps I took to generate valid binaries for the xtensa architecture with &lt;code&gt;rustc&lt;&#x2F;code&gt; and then write some &lt;code&gt;no_std&lt;&#x2F;code&gt; code to build a blinky program for the ESP32 only using Rust!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hacking-the-compiler&quot;&gt;Hacking the compiler&lt;&#x2F;h2&gt;
&lt;p&gt;In March of 2019, Espressif released their first run at an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-xtensa&quot;&gt;llvm fork&lt;&#x2F;a&gt; to support the xtensa architecure. Shortly after I got to work bootstrapping Rust to use this newly created fork. Prior to this project, I&#x27;d had no experience with the compiler, fortunately I came across the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;52787&quot;&gt;RISCV PR&lt;&#x2F;a&gt; which gave me a rough idea of what was required. After &lt;em&gt;many&lt;&#x2F;em&gt; build attempts I finally got it working; I was now able to generate xtensa assembly from Rust source code!&lt;&#x2F;p&gt;
&lt;p&gt;The next step was to assemble and link the generated assembly. The llvm fork in it&#x27;s current state cannot perform object generation, so we must use an external assembler. Luckily Rust allows us to do so by specifying the &lt;code&gt;linker_flavor&lt;&#x2F;code&gt; as &lt;code&gt;gcc&lt;&#x2F;code&gt; and providing a path to the linker with the &lt;code&gt;linker&lt;&#x2F;code&gt; target option, in this case &lt;code&gt;xtensa-esp32-elf-gcc&lt;&#x2F;code&gt;. After that I created a few built-in targets (which you can see &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&#x2F;blob&#x2F;ad570c5cb999f62a03156286fdb5d3d1bbd0fb8b&#x2F;src&#x2F;librustc_target&#x2F;spec&#x2F;xtensa_esp32_none_elf.rs&quot;&gt;here&lt;&#x2F;a&gt;); &lt;code&gt;xtensa-esp32-none-elf&lt;&#x2F;code&gt; for the ESP32; &lt;code&gt;xtensa-esp8266-none-elf&lt;&#x2F;code&gt; for the ESP8266; finally the &lt;code&gt;xtensa-unknown-none-elf&lt;&#x2F;code&gt; target for a generic xtensa target.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blinky-code&quot;&gt;Blinky code&lt;&#x2F;h2&gt;
&lt;p&gt;Now lets try and get a ESP32 board to blink the onboard LED using just Rust. First off, we need our basic program structure. The &lt;code&gt;xtensa_lx6_rt&lt;&#x2F;code&gt; crate does most of the heavy lifting in this respect, we simply need to define an entry point and the panic handler. Some of this may look vaguely familiar if you have any experience with &lt;code&gt;cortex-m&lt;&#x2F;code&gt; development on Rust, I&#x27;ve tried to mirror the API as best as I can.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]


&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; xtensa_lx6_rt as _;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;core::panic::PanicInfo;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Entry point - called by xtensa_lx6_rt after initialisation
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() -&amp;gt; ! {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{}
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Simple panic handler
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;panic_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;panic&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;PanicInfo) -&amp;gt; ! {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now lets add some register definitions for the peripherals we want to use. For our blinky program, we will need to control the GPIO peripheral. In the ESP32 (and most modern processors) peripherals are mapped to memory adresses, commonly refered to as memory mapped peripherals. To control a peripheral we simply need to write values to the right addresses in memory, with respect to the reference manual supplied by the chip manufacturer.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO output enable reg
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_ENABLE_W1TS_REG&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF44024&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO output set register
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_OUT_W1TS_REG&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF44008&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO output clear register
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_OUT_W1TC_REG &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF4400C&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; The GPIO hooked up to the onboard LED
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO function mode
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_BASE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF44530&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_SEL_CFG&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_BASE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using these definitions it should be possible to change the gpio for your board&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#gpio_pin&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; by changing the &lt;code&gt;BLINKY_GPIO&lt;&#x2F;code&gt;; for my board (NODEMCU ESP-32S) it was GPIO2.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;initialisation&quot;&gt;Initialisation&lt;&#x2F;h3&gt;
&lt;p&gt;Next lets setup the pin as a GPIO output. For the ESP32, this is a two step process&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#gpio_pin&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. Firstly, its simply a case of setting a bit in the GPIO ouput enable register. Secondly the pin has to be configured in GPIO mode. There are not enough pins for all the possible peripherals in the chip, to combat this each pin can have multiple function modes. In the case of the ESP32, each pin has up to 256 different functions, although not all are mapped. To put the pin in GPIO mode, we need to put in mode 256 (0x100), we do this by writing to the function select register. After issuing those two register writes, we should be able to turn on the GPIO by setting the relevant bit inside the GPIO set register&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() -&amp;gt; ! {

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; configure the pin as an output
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        core::ptr::write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_ENABLE_W1TS_REG &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 0x100 makes this pin a simple gpio pin - see the technical reference for more info
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;core::ptr::write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_SEL_CFG &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x100&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;); 
    }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; turn on the LED
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        core::ptr::write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_OUT_W1TS_REG &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&amp;lt; idx);           
    }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;delaying&quot;&gt;Delaying&lt;&#x2F;h3&gt;
&lt;p&gt;For the next stage of our blinky program, we need a way to delay; a simple approach could use &lt;code&gt;for&lt;&#x2F;code&gt; loop like so.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clocks&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; dummy_var: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;_ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;..clocks {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{ core::ptr::read_volatile(&amp;amp;dummy_var) };
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add the volatile read so that the compiler doesn&#x27;t optimise our delay away. The problem with this approach is that depending of the optimisation level, the number of clock cycles each iteration of the loop changes. We need a cycle accurate way of delaying, fortunately the ESP32 has an internal clock counting register which can be accessed with the read special register &lt;code&gt;rsr&lt;&#x2F;code&gt; instruction. Now are delay function looks like this.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; cycle accurate delay using the cycle counter register
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clocks&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; NOTE: does not account for rollover
    &#x2F;&#x2F; ommitted: the asm to read the ccount
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; target = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ccount&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() + clocks;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ccount&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() &amp;gt; target {
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        }
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have cycle accurate counting we can delay for one second by waiting for the number of cycles the processor will do in one second. The default clock speed on most ESP boards is 40mhz, hence waiting for 40 million cycles equates to a one second delay.&lt;&#x2F;p&gt;
&lt;p&gt;Bringing the snippets together and cleaning up the code into functions, we now have &lt;code&gt;main&lt;&#x2F;code&gt; that looks like this.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() -&amp;gt; ! {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; configure the pin as an output
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;configure_pin_as_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_led&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;CORE_HZ&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_led&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;CORE_HZ&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After flashing to the board, and firing up our JTAG debugger&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, we are greeted with a blinking LED!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;video muted controls style=&quot;width: 100%; height:auto&quot;&gt;
&lt;source src=&quot;&#x2F;esp-rust-blinky.webm&quot; type=&quot;video&#x2F;mp4&quot;&gt;
&lt;&#x2F;video&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The full source can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;the xtensa quickstart repo&lt;&#x2F;a&gt; if you wish to try it for yourself.&lt;&#x2F;p&gt;
&lt;p&gt;Now I know what most of you are thinking at this point, it&#x27;s not very Rusty; it contains bundles of unsafe and there are no real abstractions here, and you are right; but it&#x27;s something to get the ball rolling.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;&#x2F;h2&gt;
&lt;p&gt;There are a few small teething issues, but by far the biggest being issue is that the fork struggles with generating debug info; the external assembler does not support &lt;a href=&quot;https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs-2.24&#x2F;as&#x2F;CFI-directives.html#CFI-directives&quot;&gt;CFI directives&lt;&#x2F;a&gt; something that all llvm targets need to support. CFI directives can easily be removed with some preprocessing, but does of course add an extra step. After pushing past that issue, I was still getting relocation linker errors. I opened &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-xtensa&#x2F;issues&#x2F;10&quot;&gt;an issue&lt;&#x2F;a&gt; to document my findings in the hopes it can be sorted in the next iteration of the llvm fork.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;&#x2F;h2&gt;
&lt;p&gt;Once the debuginfo issue is sorted, I hope to start developing an ecosystem of HAL&#x27;s and drivers similar to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&quot;&gt;stm32-rs&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nrf-rs&quot;&gt;nrf-rs&lt;&#x2F;a&gt;; I&#x27;ve already started the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&quot;&gt;esp-rs&lt;&#x2F;a&gt; organization which is where &lt;code&gt;xtensa-lx6-rt&lt;&#x2F;code&gt; currently resides. Espressif has started the upstream process, the first ten patches are now in review, there should be an update coming to their fork moving from the older llvm6 to llvm8 (and hopefully some other additions and fixes too!).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;xtensa-quickstart&lt;&#x2F;a&gt; - A quickstart project for using Rust on xtensa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&quot;&gt;rust-xtensa&lt;&#x2F;a&gt; - The xtensa fork of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&quot;&gt;github&lt;&#x2F;a&gt; - My github&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;gpio_pin&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Note that this only applies for GPIO&#x27;s 0 to 31, the rest of the GPIO&#x27;s use a different register.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;This is not always the case if the pin the LED is connected to does not default to the correct iomux function, see the quickstart example for more info.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;This step is actually very important, currently the board will reset endlessly on boot (I assume due to the watch dog not being disabled), but launching with the debugger works as expected.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
    </channel>
</rss>
