<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Scott Mabin</title>
        <link>https://mabez.dev</link>
        <description>Scott Mabin&#x27;s blog</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://mabez.dev/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 24 Jan 2024 00:00:00 +0000</lastBuildDate>
        <item>
            <title>Rust on Espressif chips - 24-01-2024</title>
            <pubDate>Wed, 24 Jan 2024 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-24-01-2024/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-24-01-2024/</guid>
            <description>&lt;p&gt;This is the next quarterly update of the esp-rs effort, detailing the progress over Q4 2023.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-compiler&quot;&gt;Rust Compiler&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;upstream&quot;&gt;Upstream&lt;&#x2F;h3&gt;
&lt;p&gt;Over Q4 we saw many improvements to the upstream RISC-V targets. Firstly, all bare metal non-atomic (not &lt;code&gt;a&lt;&#x2F;code&gt;) targets now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;114499&quot;&gt;have atomic load&#x2F;store code generation&lt;&#x2F;a&gt; enabled! This was a massive pain point for users of the ESP32C3 and ESP32C2, along with other RISC-V targets in the wild. It&#x27;s currently still in nightly, but with the 1.76, release it will be available on stable. Secondly, we added the &lt;code&gt;riscv32imafc-unknown-none-elf&lt;&#x2F;code&gt; target, ready for the &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;news&#x2F;ESP32-P4&quot;&gt;ESP32P4&lt;&#x2F;a&gt;, Espressif&#x27;s first chip without a radio. We also promoted all the current bare metal RISC-V targets to tier 2, and in doing so, filled out the missing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;117874&quot;&gt;platform support document&lt;&#x2F;a&gt;. Finally, we added an &lt;code&gt;espidf&lt;&#x2F;code&gt; target for the ESP32P4, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;119738&quot;&gt;riscv32imafc-esp-espidf&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xtensa&quot;&gt;Xtensa&lt;&#x2F;h3&gt;
&lt;p&gt;The LLVM team at Espressif has continued to improve and rebase the Xtensa LLVM backend, which has recently been rebased on LLVM 17. Unfortunately, we don&#x27;t have any upstream progress to report at this time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-no-std&quot;&gt;esp-hal - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;Q4 saw the &lt;code&gt;v0.13&lt;&#x2F;code&gt;, &lt;code&gt;v0.14&lt;&#x2F;code&gt; and &lt;code&gt;v0.15&lt;&#x2F;code&gt; release of esp-hal. Highlights include new async drivers for PARL_IO, I2S and RMT; along with updating to the long-awaited &lt;code&gt;v1.0&lt;&#x2F;code&gt; of embedded-hal! We expanded on our low-power support by unifying the API across all chips, as well as adding ULP (Ultra-Low-Powered) core support for the ESP32S2 &amp;amp; ESP32S3. Lastly, one cool feature we implemented was &lt;code&gt;flip-link&lt;&#x2F;code&gt; for the ESP32C6 and ESP32H2, &lt;code&gt;flip-link&lt;&#x2F;code&gt; gives zero-cost stack overflow detection, which is really nice for chips like these that don&#x27;t have an MMU that can catch this in hardware. Check out the full &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md&quot;&gt;changelog&lt;&#x2F;a&gt; for all the details and changes.&lt;&#x2F;p&gt;
&lt;p&gt;One important breaking change that should be noted is that we no longer support atomic emulation, as upstream Rust now supports atomic load &amp;amp; stores on non-atomic targets. Users with applications using the ESP32S2, ESP32C3 or ESP32C2, please read &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md#breaking-1&quot;&gt;this&lt;&#x2F;a&gt; to ease upgrading. For CAS-based atomics, you should switch to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;taiki-e&#x2F;portable-atomic&quot;&gt;portable-atomic&lt;&#x2F;a&gt; crate. A huge thank you to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;taiki-e&quot;&gt;@taiki-e&lt;&#x2F;a&gt; for adding support for our targets in portable-atomic, and supporting crates, as well as pushing the atomic load&#x2F;store compiler changes through!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-wifi-no-std&quot;&gt;esp-wifi - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;In Q4 we added support for BLE with the ESP32H2, fixed coexistence support on the ESP32 and added a benchmark example to test WiFi throughput. On top of that, we finally released &lt;code&gt;esp-wifi&lt;&#x2F;code&gt; on crates.io! We spent a long time refining and documenting to get to this point and we&#x27;re pleased to have it published. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;Q4 saw the release of &lt;code&gt;v2.1.0&lt;&#x2F;code&gt; of espflash, a small release with some new functionality for erasing sectors, regions and partitions. We then began the &lt;code&gt;v3.0&lt;&#x2F;code&gt; development cycle, which will include &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-flasher-stub&quot;&gt;the Rust-based flashing stubs&lt;&#x2F;a&gt; by default! Check out the unreleased section of the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md#added&quot;&gt;changelog&lt;&#x2F;a&gt; to see what&#x27;s been added so far.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;probe-rs&quot;&gt;probe-rs&lt;&#x2F;h3&gt;
&lt;p&gt;There has been a tonne of progress with probe-rs and Espressif chips over Q4. This is all driven by the fact we want to start testing using real hardware in CI, known as Hardware In Loop (HIL) testing.&lt;&#x2F;p&gt;
&lt;p&gt;Newer Espressif chips are all RISC-V based, which probe-rs already has good support for. The ESP32, ESP32S2 and ESP32S3, however, are Xtensa-based, there for to test these in CI, we need &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;probe-rs&#x2F;probe-rs&#x2F;issues&#x2F;2001&quot;&gt;Xtensa architecture support in probe-rs&lt;&#x2F;a&gt; and that&#x27;s what we set out to do. I am happy to report that we have enough Xtensa support in probe-rs to, connect, inspect and flash the ESP32S2 and ESP32S3! This also comes with some huge speed improvements to &lt;em&gt;all&lt;&#x2F;em&gt; chips thanks to improvements in the USB-SERIAL-JTAG and FTDI drivers in probe-rs. All of this would not be possible without the help of the probe-rs team and of course the hard work of one particular individual, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bugadani&quot;&gt;Dániel Buga&lt;&#x2F;a&gt; who has been championing this work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rfc&quot;&gt;RFC&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;esp-openthread&quot;&gt;esp-openthread&lt;&#x2F;h3&gt;
&lt;p&gt;We&#x27;re looking for input on what to develop next with esp-openthread, if you are looking to use thread in your project or product, please take a look at &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-openthread&#x2F;issues&#x2F;4&quot;&gt;this RFC issue&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;&#x2F;h2&gt;
&lt;p&gt;To see what we&#x27;ll be working on this quarter, check out Jesse Braham&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;beta7.io&#x2F;posts&#x2F;esp-rs-quarterly-planning-q1-2024&#x2F;&quot;&gt;post&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 29-09-2023</title>
            <pubDate>Fri, 29 Sep 2023 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-29-09-2023/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-29-09-2023/</guid>
            <description>&lt;p&gt;This is the next quarterly update of the esp-rs effort, detailing the progress over Q3 2023.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-xtensa-compiler&quot;&gt;Rust Xtensa Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;We had one big bugfix around hardware &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;180&quot;&gt;floating point unit for ESP32 &amp;amp; ESP32-S3&lt;&#x2F;a&gt;, shout out to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;zRedShift&quot;&gt;@zRedShift&lt;&#x2F;a&gt; for finding the bug and providing the fix in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-project&#x2F;pull&#x2F;76&quot;&gt;llvm-project#76&lt;&#x2F;a&gt;. Along with the bugfix, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;zRedShift&quot;&gt;@zRedShift&lt;&#x2F;a&gt; also contributed two code generation improvement patches, one to improve the performance of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-project&#x2F;pull&#x2F;77&quot;&gt;&lt;code&gt;cttz&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and another to improve the performance of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-project&#x2F;pull&#x2F;78&quot;&gt;&lt;code&gt;abs&lt;&#x2F;code&gt;, &lt;code&gt;min&lt;&#x2F;code&gt; and &lt;code&gt;max&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. The Xtensa-related LLVM patches upstream are still in review but are slowly making progress.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-no-std&quot;&gt;esp-hal - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;Q3 saw the &lt;code&gt;v0.11&lt;&#x2F;code&gt; and &lt;code&gt;v0.12&lt;&#x2F;code&gt; release of esp-hal. Highlights include updating the &lt;code&gt;embedded-hal-*&lt;&#x2F;code&gt; packages to &lt;code&gt;1.0.0-rc.1&lt;&#x2F;code&gt;, ready for the long awaited &lt;code&gt;1.0&lt;&#x2F;code&gt; release of &lt;code&gt;embedded-hal&lt;&#x2F;code&gt;; The addition of deep-sleep support for the &lt;code&gt;ESP32-S3&lt;&#x2F;code&gt;, and new cryptographic accelerator support for ECC, HMAC and RSA. We&#x27;ve made a start on adding support for the low-power core of the ESP32-C6, with some basic GPIO drivers and support for loading the LP code from the main core. Check out the full &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md&quot;&gt;changelog&lt;&#x2F;a&gt; for all the details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-wifi-no-std&quot;&gt;esp-wifi - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;We added BLE support for the ESP32-C6 in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;262&quot;&gt;esp-wifi#262&lt;&#x2F;a&gt;, improved the esp-now async API in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;232&quot;&gt;#232&lt;&#x2F;a&gt; along with a bunch of other smaller fixes and improvements! We&#x27;re gearing up for our first crates.io release, which is long overdue. We&#x27;ve had all the pieces in place for a release, we just didn&#x27;t get around to doing it! We&#x27;re currently in the process of improving the docs, and doing some final testing before the release.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-idf-hal-std&quot;&gt;esp-idf-hal - std&lt;&#x2F;h2&gt;
&lt;p&gt;Async I2S, SPI, ADC and GPIO were added in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;279&quot;&gt;esp-idf-hal#279&lt;&#x2F;a&gt;, with a follow up PR for UART in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;306&quot;&gt;esp-idf-hal#306&lt;&#x2F;a&gt;. Huge props to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; for the tremendous effort here. From the latest &lt;code&gt;v0.42.0&lt;&#x2F;code&gt; release, ESP-IDF version 4.3 is now deprecated for use with Rust. Please see &lt;a href=&quot;https:&#x2F;&#x2F;docs.espressif.com&#x2F;projects&#x2F;esp-idf&#x2F;en&#x2F;latest&#x2F;esp32&#x2F;versions.html#support-periods&quot;&gt;ESP-IDFs support schedule&lt;&#x2F;a&gt; for upgrade paths. See the full changelog for esp-idf-hal &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;blob&#x2F;master&#x2F;CHANGELOG.md&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-idf-svc-std&quot;&gt;esp-idf-svc - std&lt;&#x2F;h2&gt;
&lt;p&gt;Bluetooth classic support (for the esp32 only at the moment) has been added, behind the &lt;code&gt;experimental&lt;&#x2F;code&gt; feature flag; BLE is also planned. We are also discussing how to go about adding generic Bluetooth traits in embedded-svc, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;embedded-svc&#x2F;issues&#x2F;32&quot;&gt;here&lt;&#x2F;a&gt;. From the latest release, it will no longer be required to depend on the esp-idf-sys crate or the esp-idf-hal crate directly in your project, instead, this crate will be re-exported by esp-idf-svc as &lt;code&gt;esp_idf_svc::sys&lt;&#x2F;code&gt; and &lt;code&gt;esp_idf_svc::hal&lt;&#x2F;code&gt; respectively.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matter-rs-rs-matter&quot;&gt;matter-rs &#x2F; rs-matter&lt;&#x2F;h2&gt;
&lt;p&gt;rs-matter (previously, matter-rs, but has been renamed due to an existing crate registered on crates.io) has had its first crates.io release! It is now async first (executor agnostic), with support for no_std out of the box, even including QR generation. The rs-matter repo now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;project-chip&#x2F;rs-matter&quot;&gt;has some examples&lt;&#x2F;a&gt; which can be run on std platforms, including the espidf std port! For &lt;code&gt;no_std&lt;&#x2F;code&gt; there are two examples of matter usage, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bjoernQ&#x2F;matter-rs-experiment&quot;&gt;one using an esp32c3 (blocking)&lt;&#x2F;a&gt; and another using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;rp-matter&quot;&gt;a rp-2040 (async)&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;Just a small patch release to report, &lt;code&gt;v2.0.1&lt;&#x2F;code&gt; which added more help text on the CLI commands, and fixed a compilation issue in the &lt;code&gt;cargo&lt;&#x2F;code&gt; dependency.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;espsegs&quot;&gt;espsegs&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bjoernQ&#x2F;espsegs&quot;&gt;espsegs&lt;&#x2F;a&gt; is a tool to see what memory is being used by which sections and where on an esp. Once installed, you can simply point the tool to an elf file, and you&#x27;ll get an output like below:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;❯ espsegs target\riscv32imc-unknown-none-elf\release\examples\embassy_dhcp --chip esp32c3
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;.text_dummy  3c000000  458784 DROM  [█████████████                                           ]
&lt;&#x2F;span&gt;&lt;span&gt;.rodata      3c070020   53060 DROM  [             █                                          ]
&lt;&#x2F;span&gt;&lt;span&gt;.rodata.wifi 3c07cf64   21756 DROM  [              ▏                                         ]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;.rwdata_dumm 3fc80000   16948 DRAM  [██████                                                  ]
&lt;&#x2F;span&gt;&lt;span&gt;.data        3fc84238    4652 DRAM  [      █                                                 ]
&lt;&#x2F;span&gt;&lt;span&gt;.bss         3fc85468  121544 DRAM  [       ████████████████████████████████████████████     ]
&lt;&#x2F;span&gt;&lt;span&gt;.data.wifi   3fca2f30     360 DRAM  [                                                    ▏   ]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;.trap        40380000    3188 IRAM  [    ▏                                                   ]
&lt;&#x2F;span&gt;&lt;span&gt;.rwtext      40380c74    2080 IRAM  [     ▏                                                  ]
&lt;&#x2F;span&gt;&lt;span&gt;.rwtext.wifi 40381494   11680 IRAM  [      ███                                               ]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;.text_init   42000020     244 IROM  [▏                                                       ]
&lt;&#x2F;span&gt;&lt;span&gt;.text        42000114  402684 IROM  [███████████                                             ]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;rfcs&quot;&gt;RFCs&lt;&#x2F;h2&gt;
&lt;p&gt;This section is mainly for users of esp-rs; we have various issues open in which we would like user feedback.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;esp-hal&quot;&gt;esp-hal&lt;&#x2F;h3&gt;
&lt;p&gt;We are considering removing direct-boot support: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;issues&#x2F;803&quot;&gt;esp-hal#803&lt;&#x2F;a&gt;, if you think this might affect you, please state your case in that issue.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;talks&quot;&gt;Talks&lt;&#x2F;h2&gt;
&lt;p&gt;Espressif recently hosted their annual developer conference, Espressif DevCon. Myself and my colleague &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;JurajSadel&quot;&gt;Juraj Sadel&lt;&#x2F;a&gt; did a short talk on using async in Rust, which you can check out below.&lt;&#x2F;p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; style=&quot;margin:auto; display: block;&quot; src=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;embed&#x2F;QPp4WEjx5jU?si=ezdXBmUTHmCxFWk_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;&#x2F;iframe&gt;
&lt;p&gt;I also did a talk at &lt;a href=&quot;https:&#x2F;&#x2F;www.meetup.com&#x2F;copenhagen-rust-community&#x2F;&quot;&gt;the Rust Copenhagen monthly meet up&lt;&#x2F;a&gt; in August. This talk is more focused on introducing embedded programming to those who already know Rust. Check it out below if you are interested.&lt;&#x2F;p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; style=&quot;margin:auto; display: block;&quot; src=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;embed&#x2F;gdmUhzJfgzk?si=GA7F_QyzQU3X198S&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;&#x2F;iframe&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 30-06-2023</title>
            <pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-30-06-2023/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-30-06-2023/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q2 2023.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-compiler&quot;&gt;Rust Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;socs&#x2F;esp32-c6&quot;&gt;ESP32-C6&lt;&#x2F;a&gt; &amp;amp; &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;socs&#x2F;esp32-h2&quot;&gt;ESP32-H2&lt;&#x2F;a&gt; use the &lt;code&gt;riscv32imac&lt;&#x2F;code&gt; compilation target, however, for our standard library port based on esp-idf, only the &lt;code&gt;riscv32imc&lt;&#x2F;code&gt; existed. We now have support for the &lt;code&gt;riscv32imac&lt;&#x2F;code&gt; target #&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;111369&quot;&gt;111369&lt;&#x2F;a&gt; meaning you can use the standard library port on the &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;socs&#x2F;esp32-c6&quot;&gt;ESP32-C6&lt;&#x2F;a&gt; &amp;amp; &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;socs&#x2F;esp32-h2&quot;&gt;ESP32-H2&lt;&#x2F;a&gt;. For those using the Xtensa enable compiler, the next release of the Rust compiler will also build and ship the &lt;code&gt;rust-analyzer-proc-macro-srv&lt;&#x2F;code&gt; component, which should fix many issues reported with rust analyzer #&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust-build&#x2F;pull&#x2F;215&quot;&gt;215&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-no-std&quot;&gt;esp-hal - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;Most of the time spent this quarter has been on &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;socs&#x2F;esp32-h2&quot;&gt;ESP32-H2&lt;&#x2F;a&gt; support. At the end of last quarter, we had some initial support but now we have managed to bring the ESP32-H2s level of support up to the level of our other chips in just a few months which is incredible. You can view the PRs for each driver &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pulls?q=is%3Apr+H2+is%3Aclosed+&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve been working hard on adding support for async in esp-hal, this includes enabling async serial read &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;620&quot;&gt;#620&lt;&#x2F;a&gt; and async serial write operations &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;510&quot;&gt;#510&lt;&#x2F;a&gt;. Additionally, we added async support to the I2C driver &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;519&quot;&gt;#519&lt;&#x2F;a&gt;. We also implemented support for multicore async GPIO &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;542&quot;&gt;#542&lt;&#x2F;a&gt;. Moreover, we made the embassy time driver more flexible by allowing the choice of either timer on chips that support it &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;609&quot;&gt;#609&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We simplified the user-facing GPIO types, hiding the implementation details and only exposing the relevant information #&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;553&quot;&gt;553&lt;&#x2F;a&gt;, which then inspired a similar change in the DMA channel types, making them more user-friendly and intuitive to use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;626&quot;&gt;#626&lt;&#x2F;a&gt;. Additionally, we enabled SPI3 for DMA on ESP32-S3 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;507&quot;&gt;#507&lt;&#x2F;a&gt;. In order to provide support for specific boards with PSRAM built-in, we introduced initial PSRAM support for ESP32 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;506&quot;&gt;#506&lt;&#x2F;a&gt; and octal PSRAM support for ESP32-S3 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;610&quot;&gt;#610&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Other noteworthy improvements include the integration of &lt;code&gt;esp-riscv-rt&lt;&#x2F;code&gt; into esp-hal &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;578&quot;&gt;#578&lt;&#x2F;a&gt;. We also simplified the &lt;code&gt;Delay&lt;&#x2F;code&gt; driver and now derive &lt;code&gt;Clone&lt;&#x2F;code&gt; and &lt;code&gt;Copy&lt;&#x2F;code&gt; traits. We also move interrupt handling code to RAM for improved interrupt performance &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;568&quot;&gt;#568&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;541&quot;&gt;#541&lt;&#x2F;a&gt;. Additionally, we addressed a bug related to setting the vector base for the second core on Xtensa-based CPUs &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;536&quot;&gt;#536&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-wifi-no-std&quot;&gt;esp-wifi - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;We have removed the hard requirement for timg0 as the main timer, offering more configuration flexibility &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;199&quot;&gt;#199&lt;&#x2F;a&gt;. Additionally, we reworked the initialization process to ensure proper initialization of both the hardware and scheduler &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;194&quot;&gt;#194&lt;&#x2F;a&gt;. To enhance WiFi performance, we made &lt;code&gt;preempt&lt;&#x2F;code&gt; improvements, resulting in better overall performance and responsiveness &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;185&quot;&gt;#185&lt;&#x2F;a&gt;. We also expanded the capabilities of the built-in stack by adding basic IPv6 support &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;181&quot;&gt;#181&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-ieee802154-no-std&quot;&gt;esp-ieee802154 - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;The newly introduced ESP32-C6 &amp;amp; ESP32-H2 include an 802.15.4 radio, which is a low-power, low-rate standard intended for embedded devices. The &lt;code&gt;esp-ieee802154&lt;&#x2F;code&gt; crate implements the low-level driver for the radio in both chips, entirely in Rust and completely open source&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;! This is a big leap from our WiFi drivers, where we interface with binary blobs over the C FFI. There are some useful examples in the repository, including a &lt;code&gt;sniffer&lt;&#x2F;code&gt; example to receive raw 802.15.4 frames. In the next few months, we will begin working on getting this driver to work with &lt;a href=&quot;https:&#x2F;&#x2F;openthread.io&#x2F;&quot;&gt;&lt;code&gt;openthread&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-idf-std&quot;&gt;esp-idf - std&lt;&#x2F;h2&gt;
&lt;p&gt;We added safe abstractions to the CRC functions in ESP ROM in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;261&quot;&gt;#261&lt;&#x2F;a&gt;. We also introduced support for &lt;code&gt;WakeupReason&lt;&#x2F;code&gt; from &lt;code&gt;Ext0&lt;&#x2F;code&gt; events, allowing for more fine-grained control over wakeup behavior &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;259&quot;&gt;#259&lt;&#x2F;a&gt;. Additionally, we implemented I2S, enabling communication with I2S peripherals &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;232&quot;&gt;#232&lt;&#x2F;a&gt;. Furthermore, we incorporated changes from the newest embedded-hal release into our drivers, ensuring compatibility and staying up-to-date with the latest improvements in the embedded-hal ecosystem &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;224&quot;&gt;#224&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In esp-idf-svc, we focused on expanding the capabilities of the server examples by adding higher-level server examples, providing more comprehensive and practical usage scenarios &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-svc&#x2F;pull&#x2F;269&quot;&gt;#269&lt;&#x2F;a&gt;. We also exposed a simple safe wrapper for querying rssi when using WiFi &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-svc&#x2F;pull&#x2F;245&quot;&gt;#245&lt;&#x2F;a&gt;. Additionally, we now support async and blocking adaptors for the WiFi driver &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-svc&#x2F;pull&#x2F;243&quot;&gt;#243&lt;&#x2F;a&gt;. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;The highlight of this cycle was the release of Version 2.0.0, which marked a major milestone for the project and introduced substantial enhancements &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;434&quot;&gt;#434&lt;&#x2F;a&gt;. Please read the full &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md&quot;&gt;CHANGELOG&lt;&#x2F;a&gt; before upgrading. &lt;&#x2F;p&gt;
&lt;p&gt;We also invested effort in refining the release and CI workflows, resulting in smoother and more efficient processes &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;421&quot;&gt;#421&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;419&quot;&gt;#419&lt;&#x2F;a&gt;. We addressed specific issues such as missing imports for &lt;code&gt;linux&lt;&#x2F;code&gt; and &lt;code&gt;musl&lt;&#x2F;code&gt; environments &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;420&quot;&gt;#420&lt;&#x2F;a&gt; and improved handling of serial ports on BSD systems &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;415&quot;&gt;#415&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In terms of usability and user experience, we eliminated the need for the &lt;code&gt;--partition-table&lt;&#x2F;code&gt; argument when erasing partitions, simplifying the process &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;413&quot;&gt;#413&lt;&#x2F;a&gt;. We also updated to the latest version of &lt;code&gt;addr2line&lt;&#x2F;code&gt; and addressed breaking changes before releasing 2.0.0 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;412&quot;&gt;#412&lt;&#x2F;a&gt;. Furthermore, we improved error messaging by rewording the &amp;quot;elf too big&amp;quot; error and fixed the Windows installation process for smoother setup &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;400&quot;&gt;#400&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;399&quot;&gt;#399&lt;&#x2F;a&gt;. Additionally, we introduced a diagnostic feature that informs users about the partition table format, aiding troubleshooting &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;397&quot;&gt;#397&lt;&#x2F;a&gt;. To ensure compatibility and expand our supported targets, we updated the flasher stubs and bootloaders &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;426&quot;&gt;#426&lt;&#x2F;a&gt; and the supported targets for ESP32-C6&#x2F;H2 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;424&quot;&gt;#424&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;probe-rs&quot;&gt;probe-rs&lt;&#x2F;h3&gt;
&lt;p&gt;We&#x27;ve had flashing support in probe-rs for a couple of years now, but it was only possible to flash a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp32c3-direct-boot-example&quot;&gt;direct-boot application&lt;&#x2F;a&gt;, but we now support the esp-idf bootloader format in probe-rs #&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;probe-rs&#x2F;probe-rs&#x2F;pull&#x2F;1629&quot;&gt;1629&lt;&#x2F;a&gt;. We also have improved the performance of using the built-in USB-SERIAL-JTAG peripheral available on many Espressif chips, resulting in up to a 10x improvement in flashing times and a better overall debugging experience #&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;probe-rs&#x2F;probe-rs&#x2F;pull&#x2F;1633&quot;&gt;1633&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matter-rs&quot;&gt;matter-rs&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Matter_(standard)&quot;&gt;matter&lt;&#x2F;a&gt; is an open-source connectivity standard for smart home and Internet of things devices, that promises to make smart devices work with each other regardless of which company manufactures them. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;project-chip&#x2F;matter-rs&quot;&gt;matter-rs&lt;&#x2F;a&gt; is a pure Rust implementation of the matter protocol. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kedars&quot;&gt;@kedars&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; have been working hard to bring both &lt;code&gt;no_std&lt;&#x2F;code&gt; support and &lt;code&gt;async&lt;&#x2F;code&gt; support to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;project-chip&#x2F;matter-rs&quot;&gt;matter-rs&lt;&#x2F;a&gt;. For more information on the active development branches see &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;project-chip&#x2F;matter-rs#important-note&quot;&gt;this section of the readme&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;community&quot;&gt;Community&lt;&#x2F;h2&gt;
&lt;p&gt;If you look closer at the individual PRs in this post you will see that many of the contributions are now coming from community members instead of just us at Espressif. This is &lt;em&gt;really&lt;&#x2F;em&gt; exciting and humbling to see, and we can&#x27;t thank the community enough! If you are interested in getting involved or just want to see what we&#x27;re up to, come say hi in the &lt;a href=&quot;https:&#x2F;&#x2F;matrix.to&#x2F;#&#x2F;#esp-rs:matrix.org&quot;&gt;esp-rs matrix&lt;&#x2F;a&gt; channel.&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;phy initialization is still done through binary blobs, but after that, the entire driver is controlled via open-source Rust code.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 28-04-2023</title>
            <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-28-04-2023/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-28-04-2023/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q1 2023.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-compiler-llvm&quot;&gt;Rust Compiler &amp;amp; LLVM&lt;&#x2F;h2&gt;
&lt;p&gt;We have fixed several issues in the LLVM Xtensa backend, mainly relating to the hardware loop optimization feature used on the ESP32 and ESP32-S3 chips &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;161&quot;&gt;#161&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;164&quot;&gt;#164&lt;&#x2F;a&gt;. We spotted an issue with the 1.67 release where debug builds no longer worked on the ESP32, however, this turned out to be a linker script issue in esp-hal &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;158&quot;&gt;#158&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In the last post, we mentioned that the first 10 LLVM Xtensa patches had been committed upstream, since then we have been preparing the next set and now have 20 patches in review upstream. You can track the progress, as well as review the patches &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-project&#x2F;issues&#x2F;4#issuecomment-1485724130&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-no-std&quot;&gt;esp-hal - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;First, there were updates to the &lt;code&gt;embedded-hal-async&lt;&#x2F;code&gt; and &lt;code&gt;embassy-*&lt;&#x2F;code&gt; dependencies, as well as an update to &lt;code&gt;embedded-hal@1.0.0-alpha.10&lt;&#x2F;code&gt; and &lt;code&gt;embedded-hal-nb@1.0.0-alpha.2&lt;&#x2F;code&gt;, bringing in the latest changes and improvements from the embedded-hal ecosystem &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;488&quot;&gt;#488&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;487&quot;&gt;#487&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Initial ESP32-H2 support was added with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;482&quot;&gt;#482&lt;&#x2F;a&gt; with the addition of soc&#x2F;efuse methods in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;486&quot;&gt;#486&lt;&#x2F;a&gt;. Debug assist support was added to aid in debugging stack overflow issues &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;484&quot;&gt;#484&lt;&#x2F;a&gt;. Additional updates were made to fix comparison errors, decoding of wakeup cause using bitflags, as well as adding support for the RSA peripheral &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;473&quot;&gt;#473&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;472&quot;&gt;#472&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;467&quot;&gt;#467&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Improvements were made to the linker scripts, documentation, and clock control for peripherals such as &lt;code&gt;timg&lt;&#x2F;code&gt;, &lt;code&gt;wdt&lt;&#x2F;code&gt;, &lt;code&gt;sha&lt;&#x2F;code&gt;, &lt;code&gt;usb-serial-jtag&lt;&#x2F;code&gt;, and &lt;code&gt;uart&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;470&quot;&gt;#470&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;463&quot;&gt;#463&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;461&quot;&gt;#461&lt;&#x2F;a&gt;. Fixes were made to clock enabling for ESP32-C6 and 802.15.4 clock enabling for ESP32-C6 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;458&quot;&gt;#458&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Updates were made to the PACs (Peripheral Access Crates) to the latest versions, and the &lt;code&gt;esp-hal-smartled&lt;&#x2F;code&gt; package was extracted and CI checks were added for it &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;447&quot;&gt;#447&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;436&quot;&gt;#436&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;429&quot;&gt;#429&lt;&#x2F;a&gt;. Other changes included fixing warnings, cleaning up the RTC driver, removing r0 dependency, and unifying linker scripts for better organization and maintenance &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;440&quot;&gt;#440&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;439&quot;&gt;#439&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;443&quot;&gt;#443&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-wifi-no-std&quot;&gt;esp-wifi - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;We have made significant progress in enhancing packet dumps &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;165&quot;&gt;#165&lt;&#x2F;a&gt; and using a more reasonable default MTU, as well as incorporating features to change MTU &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;164&quot;&gt;#164&lt;&#x2F;a&gt;. Additionally, we have implemented async BLE functionality &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;161&quot;&gt;#161&lt;&#x2F;a&gt; and added missing ROM functions for ESP32-S3&#x2F;ESP32-S2 support &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;160&quot;&gt;#160&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We now utilize types from &lt;code&gt;core::ffi::&lt;&#x2F;code&gt; since they have been stabilized &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;159&quot;&gt;#159&lt;&#x2F;a&gt; and incorporated the use of HAL&#x27;s radio clock control &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;153&quot;&gt;#153&lt;&#x2F;a&gt;. We have also refactored &lt;code&gt;Socket::write&lt;&#x2F;code&gt; to prevent infinite loops during long writes &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;151&quot;&gt;#151&lt;&#x2F;a&gt; and updated examples for better organization and clarity &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;146&quot;&gt;#146&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In terms of new features, we have added support for ESP32-C6 WiFi &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;142&quot;&gt;#142&lt;&#x2F;a&gt;, implemented basic AP functionality &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;134&quot;&gt;#134&lt;&#x2F;a&gt;, and incorporated ESP-NOW support &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;121&quot;&gt;#121&lt;&#x2F;a&gt;. We have also made improvements to asynchronous WiFi functionality, including &lt;code&gt;connect&#x2F;disconnect&#x2F;scan&#x2F;wait_for_event&lt;&#x2F;code&gt; capabilities &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;129&quot;&gt;#129&lt;&#x2F;a&gt; and fixed a bug ensuring that internal WiFi buffers are properly freed &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;128&quot;&gt;#128&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, we have made updates to dependencies, such as upgrading to Smoltcp 0.9 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;124&quot;&gt;#124&lt;&#x2F;a&gt;, and reorganizing low-level bindings into a separate package for better modularity &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;117&quot;&gt;#117&lt;&#x2F;a&gt;. We have also addressed various bug fixes and optimizations, including disabling LTO for improved performance &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;116&quot;&gt;#116&lt;&#x2F;a&gt; and refactoring the WiFi device for better code structure &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;115&quot;&gt;#115&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tls-no-std&quot;&gt;TLS - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;The standard library has had TLS support for a while, but it&#x27;s not flawless. However, we lacked TLS support for no_std applications. While we&#x27;re enthusiastic about the potential of the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;drogue-iot&#x2F;embedded-tls&quot;&gt;embedded-tls&lt;&#x2F;a&gt; crate, it&#x27;s not yet suitable for widespread use. As a substitute, we created &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-mbedtls&quot;&gt;esp-mbedtls&lt;&#x2F;a&gt;, a crate for using MbedTLS on ESP32s in no_std applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-idf-std&quot;&gt;esp-idf - std&lt;&#x2F;h2&gt;
&lt;p&gt;Over the past quarter, we have been busy improving the functionality and usability of the esp-idf-hal library. We fixed thread priority with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;235&quot;&gt;#235&lt;&#x2F;a&gt;, and improved our CI with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;226&quot;&gt;#226&lt;&#x2F;a&gt;. Additionally, we added an &lt;code&gt;spi::config::BitOrder&lt;&#x2F;code&gt; enum to make SPI configuration more flexible with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;222&quot;&gt;#222&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We also implemented several new features, such as setting the &lt;code&gt;LedcTimerDriver&lt;&#x2F;code&gt; frequency with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;219&quot;&gt;#219&lt;&#x2F;a&gt;, and implementing async Wait traits from embedded-hal-async with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;218&quot;&gt;#218&lt;&#x2F;a&gt;. We also added alerts and modes support for TWAI with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;216&quot;&gt;#216&lt;&#x2F;a&gt;, and implemented a general purpose delay provider with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;210&quot;&gt;#210&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we made several improvements to existing functionality, including allowing setting a timeout for i2c to accommodate devices with longer clock stretching with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;211&quot;&gt;#211&lt;&#x2F;a&gt;, and changing the LEDC Clock enum name&#x2F;typedef in esp-idf master with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;208&quot;&gt;#208&lt;&#x2F;a&gt;. We also implemented PCNT for the v4 esp-idf api (which will work for v5 with v4 api) with pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;157&quot;&gt;#157&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;Over the past quarter, we and the community have been busy making several improvements and fixes to &lt;code&gt;espflash&lt;&#x2F;code&gt;. We started by adding a note about permissions on Linux in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;391&quot;&gt;#391&lt;&#x2F;a&gt; to ensure that users are aware of the necessary permissions when flashing ESP devices on Linux systems. In pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;389&quot;&gt;#389&lt;&#x2F;a&gt;, we made the default flashing frequency target specific to improve the flashing process. We also generated shell completions in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;388&quot;&gt;#388&lt;&#x2F;a&gt; to enhance the usability of the &lt;code&gt;espflash&lt;&#x2F;code&gt; tool.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to these improvements, we also focused on fixing issues and bugs. We fixed the config file parsing in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;382&quot;&gt;#382&lt;&#x2F;a&gt; and updated the &lt;code&gt;toml&lt;&#x2F;code&gt; dependency while fixing errors and feature gating &lt;code&gt;ctrlc&lt;&#x2F;code&gt; dependency in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;378&quot;&gt;#378&lt;&#x2F;a&gt;. We also resolved issues with Raspberry CI in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;377&quot;&gt;#377&lt;&#x2F;a&gt; to ensure smooth integration and testing. Furthermore, we made image header improvements and bugfixes in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;375&quot;&gt;#375&lt;&#x2F;a&gt;, fixed chip revision check during flashing for the ESP8266 in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;373&quot;&gt;#373&lt;&#x2F;a&gt;, and restored the cursor when exiting from serial port selection via Ctrl-C in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;372&quot;&gt;#372&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In terms of new features, we added support for ESP32-H2 in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;371&quot;&gt;#371&lt;&#x2F;a&gt; and introduced an &lt;code&gt;ESPFLASH_PORT&lt;&#x2F;code&gt; environment variable in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;366&quot;&gt;#366&lt;&#x2F;a&gt; for added flexibility. We also updated the documentation in pull request &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;368&quot;&gt;#368&lt;&#x2F;a&gt; to provide up-to-date and accurate information to users. Additionally, we made several fixes and improvements in pull requests such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;363&quot;&gt;#363&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;359&quot;&gt;#359&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;358&quot;&gt;#358&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;354&quot;&gt;#354&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;353&quot;&gt;#353&lt;&#x2F;a&gt; to ensure the stability and reliability of the &lt;code&gt;espflash&lt;&#x2F;code&gt; tool. Overall, our team has been actively working on addressing issues, adding new features, and improving the &lt;code&gt;espflash&lt;&#x2F;code&gt; repository to provide a better experience for our users.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matter&quot;&gt;matter&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Matter_(standard)&quot;&gt;matter&lt;&#x2F;a&gt; is an open-source connectivity standard for smart home and Internet of things devices, that promises to make smart devices work with each other regardless of which company manufactures them. We at Espressif are very interested in supporting this. ESP-IDF has support for it with the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-matter&quot;&gt;esp-matter&lt;&#x2F;a&gt; repository, which uses the C++ matter SDK, which we could of course write bindings to (we&#x27;ve already played around with this!) but ideally we&#x27;d love a pure Rust implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Introducing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;project-chip&#x2F;matter-rs&quot;&gt;matter-rs&lt;&#x2F;a&gt; a pure Rust implementation of the matter protocol. Espressif&#x27;s very own &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kedars&quot;&gt;@kedars&lt;&#x2F;a&gt; lead the development of this library, and it is now the official implementation adopted by the matter organization. There are many improvements and features to be added such as &lt;code&gt;async&lt;&#x2F;code&gt; and &lt;code&gt;no_std&lt;&#x2F;code&gt; support but it&#x27;s a great start.&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 2023 Roadmap</title>
            <pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-24-02-2023/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-24-02-2023/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q4 2022 as well as a roadmap for 2023.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-compiler-llvm&quot;&gt;Rust Compiler &amp;amp; LLVM&lt;&#x2F;h2&gt;
&lt;p&gt;Other than the occasional rebase for every Rust release, there is not too much to report on the rust compiler fork. However, we have really exciting news about LLVM. The first 10 Xtensa patches have been approved and &lt;em&gt;committed&lt;&#x2F;em&gt; upstream 🎉, you can view them &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Allvm%2Fllvm-project+Xtensa&amp;amp;type=commits&quot;&gt;here&lt;&#x2F;a&gt;. This is exciting for us, Espressif has been pushing this upstreaming effort since 2019! So it&#x27;s very nice to have something upstream, with plenty more patches to follow. At this point, I&#x27;d also like to make it clear that you do &lt;strong&gt;not&lt;&#x2F;strong&gt; need the forked compiler for our RISC-V-based chips, esp32c2, esp32c3, esp32c6 etc. You only need the forked compiler for our Xtensa-based chips, esp32, esp32s2 &amp;amp; esp32s3.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espup&quot;&gt;espup&lt;&#x2F;a&gt;, our custom toolchain manager has seen some nice improvements over the quarter. It now leverages &lt;code&gt;async&lt;&#x2F;code&gt; to improve installation times, by downloading multiple things concurrently. We switched to espup in our CI pipelines and saw a significant improvement in setup time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-no-std&quot;&gt;esp-hal - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&quot;&gt;esp-hal&lt;&#x2F;a&gt; has seen two releases in the last quarter, adding many features including our first async driver, async GPIO.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Async: GPIO - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;333&quot;&gt;#333&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Rework the CI workflow - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;343&quot;&gt;#343&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Remove the signals from the GPIO structs - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;337&quot;&gt;#337&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix GPIO interrupts for pins &amp;gt; 31 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;335&quot;&gt;#335&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Finish PeripheralRef - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;334&quot;&gt;#334&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Use the latest PACs - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;331&quot;&gt;#331&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix the CI badge - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;330&quot;&gt;#330&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;pulse counter implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;328&quot;&gt;#328&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;enable TWAI on ESP32-S3 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;325&quot;&gt;#325&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Completely remove pac references in hal drivers - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;309&quot;&gt;#309&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Support ESP32-C2 with 26MHz Xtal - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;301&quot;&gt;#301&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add a CI job to verify formatting - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;297&quot;&gt;#297&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;New releases for all HALs - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;296&quot;&gt;#296&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix LEDC duty-cycle updates - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;294&quot;&gt;#294&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Correct Systimer delay implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;293&quot;&gt;#293&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix ESP32-C2 trap handler - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;292&quot;&gt;#292&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Embassy init updates - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;290&quot;&gt;#290&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add cfg symbols for &lt;code&gt;i2s&lt;&#x2F;code&gt; and &lt;code&gt;mcpwm&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;289&quot;&gt;#289&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Pass trap frame to CPU interrupt handlers (Xtensa) - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;286&quot;&gt;#286&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix clippy warnings, update READMEs - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;284&quot;&gt;#284&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;remove &lt;code&gt;i2c::SetupError&lt;&#x2F;code&gt; and make &lt;code&gt;i2c::I2C::new&lt;&#x2F;code&gt; infallible - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;281&quot;&gt;#281&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;GPIO module refactoring - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;280&quot;&gt;#280&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Export InputSignal and OutputSignal - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;276&quot;&gt;#276&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Finalize I2S RX Implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;274&quot;&gt;#274&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update install sections - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;273&quot;&gt;#273&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;PeripheralRef init: uart - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;272&quot;&gt;#272&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implemented ability to write bytes in &lt;code&gt;UsbSerialJtag&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;271&quot;&gt;#271&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix example in esp-hal-procmacros::interrupt doc - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;270&quot;&gt;#270&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add Rx and interrupts to UsbSerialJtag - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;267&quot;&gt;#267&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Avoid potential linker error for ESP32-C2 and ESP32-C3 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;266&quot;&gt;#266&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;New releases for all HALs - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;265&quot;&gt;#265&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add more configuration symbols and simplify the build script - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;264&quot;&gt;#264&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Detangle I2C clock calculation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;263&quot;&gt;#263&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Preliminary I2S Implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;262&quot;&gt;#262&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix UART unlisten calls so they clear the interrupt enable - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;261&quot;&gt;#261&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add more trait re-exports to prelude module - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;260&quot;&gt;#260&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update all PACs to their latest versions - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;259&quot;&gt;#259&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add SHA accelerator implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;257&quot;&gt;#257&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;doc: add &lt;code&gt;#[doc(inline)]&lt;&#x2F;code&gt; to esp-hal-common re-exports - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;256&quot;&gt;#256&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;MCPWM MVP implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;255&quot;&gt;#255&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add Mcpwm0 and Mcpwm1 to &lt;code&gt;system::Peripheral&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;254&quot;&gt;#254&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;add&#x2F;correct docs for gpio::OutputSignal and add PWM output signal to ESP32-S3 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;251&quot;&gt;#251&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add LEDC support for ESP32-C2 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;250&quot;&gt;#250&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update to newest PACs for C2&#x2F;C3&#x2F;S3 and clean up GDMA implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;248&quot;&gt;#248&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add uninit section to bl and mv linker scripts to match db - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;246&quot;&gt;#246&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;ADC: Refactor, join S2 and S3 together and C2 and C3 as well - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;245&quot;&gt;#245&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;ESP32-C2 APB clock is 40MHz, not 80MHz - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;244&quot;&gt;#244&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;esp-wifi-no-std&quot;&gt;esp-wifi - no_std&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&quot;&gt;esp-wifi&lt;&#x2F;a&gt; saw some nice features over the last quarter, along with some bug fixes, performance improvements and refactors.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ESP32-C2 BLE - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;110&quot;&gt;#110&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;WiFi for ESP32-C2 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;107&quot;&gt;#107&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update Drivers - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;106&quot;&gt;#106&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;BTLE for ESP32-S3 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;105&quot;&gt;#105&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add &lt;code&gt;ps_min_modem&lt;&#x2F;code&gt; feature - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;103&quot;&gt;#103&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Misc improvements - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;102&quot;&gt;#102&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update dependencies - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;100&quot;&gt;#100&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Have a way to yield from a task - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;98&quot;&gt;#98&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Re-introduce a Queue for TX - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;96&quot;&gt;#96&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add static IP and socket listening example - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;95&quot;&gt;#95&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix ESP32-C3 development mode - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;90&quot;&gt;#90&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Works on ESP32-C3-DevKit-RUST-1 again - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;86&quot;&gt;#86&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update embedded svc - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;84&quot;&gt;#84&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Support multiple sockets, UDP and multicast - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;82&quot;&gt;#82&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix the newest ESP-HALs Alarm&#x27;s method - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;81&quot;&gt;#81&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update README.md wording - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;75&quot;&gt;#75&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;esp-idf-std&quot;&gt;esp-idf - std&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;General purpose delay provider - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;210&quot;&gt;#210&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;LEDC Clock enum name&#x2F;typedef change in esp-idf master - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;208&quot;&gt;#208&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update &lt;code&gt;xtensa-toolchain&lt;&#x2F;code&gt; action - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;206&quot;&gt;#206&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix issue #201: Use &lt;code&gt;NonZeroUsize&lt;&#x2F;code&gt; to specify DMA transfer size - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;203&quot;&gt;#203&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add queue length to CAN config - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;202&quot;&gt;#202&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix a typo - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;196&quot;&gt;#196&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Correct endianness of RMT signal in neopixel example - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;195&quot;&gt;#195&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add input_delay_ns to config struct - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;192&quot;&gt;#192&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add auto_reload functionality to timers - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;190&quot;&gt;#190&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Use &lt;code&gt;EspError::from_infallible&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;189&quot;&gt;#189&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;#180 ledcdriver redundand timer config - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;188&quot;&gt;#188&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Adjust for &lt;code&gt;esp-idf-sys&lt;&#x2F;code&gt; size_t -&amp;gt; usize - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;185&quot;&gt;#185&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Ci for idf 5.0 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;183&quot;&gt;#183&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement watchdog interface - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;182&quot;&gt;#182&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix typo in doc copy - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;181&quot;&gt;#181&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement exclusive SPI Bus - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;174&quot;&gt;#174&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Use &lt;code&gt;Cell&amp;lt;Option&amp;lt;NonNull&amp;lt;QueueDefinition&amp;gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt; instead of &lt;code&gt;UnsafeCell&amp;lt;*mut QueueDefinition&amp;gt;&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;170&quot;&gt;#170&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;do some clippy&#x2F;Cargo.toml housekeeping, update &lt;code&gt;st7789&lt;&#x2F;code&gt; example to use a non-deprecated driver - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;169&quot;&gt;#169&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add can custom timing - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;166&quot;&gt;#166&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Overhaul UART to support single wire transmitters&#x2F;receivers - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;164&quot;&gt;#164&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;PCNT implementation for v4 esp-idf api (will work for on v5 with v4 api) - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;157&quot;&gt;#157&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Ledc: Add &lt;code&gt;SpeedMode&lt;&#x2F;code&gt; enum, allow &lt;code&gt;lpoint&lt;&#x2F;code&gt; &amp;lt; &lt;code&gt;hpoint&lt;&#x2F;code&gt; &amp;lt; &lt;code&gt;max_duty&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;155&quot;&gt;#155&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix GPIO docstrings - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;151&quot;&gt;#151&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;RFC: Multi CS Spi Implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;150&quot;&gt;#150&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add half duplex and 3wire mode support to SPI - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;143&quot;&gt;#143&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;spi&#x2F;adc_st7789_example - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;125&quot;&gt;#125&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add RMT receiver - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&#x2F;pull&#x2F;104&quot;&gt;#104&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Make &lt;code&gt;Interface&lt;&#x2F;code&gt; constructor public - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;354&quot;&gt;#354&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix CI warnings - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;350&quot;&gt;#350&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Remove the USB Serial JTAG watchdog workaround now that we use the stub - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;345&quot;&gt;#345&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;No longer build releases for the Windows GNU target - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;343&quot;&gt;#343&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Organize, simplify, and generally improve the errors - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;342&quot;&gt;#342&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;If a bootloader and&#x2F;or partition table other than the defaults have been provided, indicate such - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;339&quot;&gt;#339&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Mark public enums as &lt;code&gt;#[non_exhaustive]&lt;&#x2F;code&gt; for semver compatibility - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;338&quot;&gt;#338&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Use the flasher stub by default - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;337&quot;&gt;#337&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;CLI improvements and dependency updates - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;334&quot;&gt;#334&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add an optional callback trait which can be implemented and provided to most flashing functions - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;333&quot;&gt;#333&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix monitor after flash for ESP32-C2 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;330&quot;&gt;#330&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Make the flasher return a struct of device information instead of printing directly - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;328&quot;&gt;#328&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Mention the bootloader&#x2F;partition table auto-detection feature of &lt;code&gt;cargo-espflash&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;327&quot;&gt;#327&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix the CI badge in the README - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;325&quot;&gt;#325&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Reorder ports so that known ports appear first in CLI - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;324&quot;&gt;#324&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Support ESPFLASH_BAUD env var - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;322&quot;&gt;#322&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for flashing the ESP32-C6 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;317&quot;&gt;#317&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix the serial monitor when using 26MHz ESP32-C2 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;315&quot;&gt;#315&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix crystal frequency detection for ESP32-C2 and ESP8266 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;314&quot;&gt;#314&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Version 2.0.0-rc.2 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;309&quot;&gt;#309&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix typo in &lt;code&gt;ImageFormatKind&lt;&#x2F;code&gt;&#x27;s &lt;code&gt;FromStr&lt;&#x2F;code&gt; implementation - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;308&quot;&gt;#308&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Display the newer &#x27;v{major}.{minor}&#x27; chip revision format - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;307&quot;&gt;#307&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Make command module public - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;303&quot;&gt;#303&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Clean up unused code, optimize comparison in &lt;code&gt;find_serial_port&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;302&quot;&gt;#302&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for using custom cargo metadata when in a workspace - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;300&quot;&gt;#300&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Update dependencies to their latest versions - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;299&quot;&gt;#299&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add shortopt -M for --monitor - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;296&quot;&gt;#296&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Allow SerialPortType::PciPort during port detection - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;295&quot;&gt;#295&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Report the image and partition size in the error - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;293&quot;&gt;#293&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add option to supply the &lt;code&gt;ELF&lt;&#x2F;code&gt; image path in the monitor subcommand - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;292&quot;&gt;#292&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Version 2.0.0-rc.1 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;288&quot;&gt;#288&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Make the &lt;code&gt;interface&lt;&#x2F;code&gt; module public - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;287&quot;&gt;#287&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix &lt;code&gt;FlashSize&lt;&#x2F;code&gt; discrepancy between &lt;code&gt;clap&lt;&#x2F;code&gt;, &lt;code&gt;strum&lt;&#x2F;code&gt; and &lt;code&gt;FromStr&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;286&quot;&gt;#286&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Only display progress bars when &lt;code&gt;cli&lt;&#x2F;code&gt; feature is enabled, allow passing progress callback - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;283&quot;&gt;#283&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Print app size when using any image format, cleanup&#x2F;use new features - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;281&quot;&gt;#281&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add updated bootloaders for all chips - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;278&quot;&gt;#278&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Load stubs from TOML instead of JSON files - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;277&quot;&gt;#277&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add a test for the Direct Boot image format - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;276&quot;&gt;#276&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Extract common functionality for erasing partition tables into a function - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;275&quot;&gt;#275&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Replace --erase-otadata with --erase-parts and --erase-data-parts - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;273&quot;&gt;#273&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Print additional information when invoking the &lt;code&gt;save-image&lt;&#x2F;code&gt; subcommand - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;272&quot;&gt;#272&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Additional docstrings for &lt;code&gt;enums&lt;&#x2F;code&gt;, &lt;code&gt;structs&lt;&#x2F;code&gt;, and &lt;code&gt;traits&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;271&quot;&gt;#271&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;connection: error handling - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;270&quot;&gt;#270&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;connection: Swap error and status in CommandResponse - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;269&quot;&gt;#269&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add back the image format tests which had been previously removed - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;266&quot;&gt;#266&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Remove unneeded attributes and &lt;code&gt;pub(crate)&lt;&#x2F;code&gt;s, old test data - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;263&quot;&gt;#263&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;the-2023-roadmap&quot;&gt;The 2023 roadmap&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve been thinking about what we&#x27;d like to achieve in the next year, and have put together a roadmap for 2023.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;async&quot;&gt;Async&lt;&#x2F;h3&gt;
&lt;p&gt;Over the last year, we&#x27;ve made a real effort to get blocking implementations available for most peripherals both in our Standard library effort, and no_std efforts. Blocking is generally simpler to implement, as async relies on a good story for interrupts &amp;amp; DMA (direct memory access). This year we&#x27;d like to push for more async across both approaches; this includes async peripheral drivers (SPI, UART, I2C etc), including but not limited to the &lt;code&gt;embedded-hal-async&lt;&#x2F;code&gt; traits, as well as async networking solutions. Those of you familiar with the Standard library approach may have noticed there is actually quite a good async networking solution already available using &lt;code&gt;smol-rs&lt;&#x2F;code&gt; but we need to upstream many of our changes. Our main focus for no_std async networking will be on the &lt;code&gt;esp-wifi&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chip-support&quot;&gt;Chip support&lt;&#x2F;h3&gt;
&lt;p&gt;For both approaches, we will be adding support for the newly released ESP32-C6, as well as preparing support for the ESP32-H2 and ESP32-P4 once they are officially released. Support for the ESP32-C6 is in progress for no_std, and for STD, ESP32C6 support will be added with the release of esp-idf v5.1 (expected in May).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;low-power-modes-and-co-processor-support&quot;&gt;Low Power modes and co-processor support&lt;&#x2F;h3&gt;
&lt;p&gt;Starting from the ESP32-S2, our chips have included a low-power RISC-V coprocessor for handling low-power operations when the main CPU is not needed. We&#x27;d like to leverage &lt;code&gt;esp-hal&lt;&#x2F;code&gt; for creating applications that can run on the constrained low-power core, for both no_std &lt;em&gt;and&lt;&#x2F;em&gt; std applications. The low-power core is too resource-constrained to run the full standard library, so using &lt;code&gt;esp-hal&lt;&#x2F;code&gt; makes perfect sense here.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;std-build-times&quot;&gt;STD build times&lt;&#x2F;h3&gt;
&lt;p&gt;One of the barriers when developing for the STD platform is build times. We know of several improvements we can make to reduce the build time. One thing we&#x27;d like to take a look at this year is slimming down the esp-idf build, currently, we build everything, but esp-idf is made of components, which can be disabled if they&#x27;re not needed. We&#x27;re also aware that a lot of the &#x27;build&#x27; time is spent downloading esp-idf sources via git, so we&#x27;d like to investigate how to reduce this time.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;documentation&quot;&gt;Documentation&lt;&#x2F;h3&gt;
&lt;p&gt;We&#x27;ve made a lot of progress over the last year, but moving so fast has left the documentation situation in a not-so-great state. We&#x27;re rewriting &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;the book&lt;&#x2F;a&gt; this year to cut out irrelevant, outdated information as well as fill the gaps created in the last year. We&#x27;re currently self-hosting our standard library documentation because we need an internet connection to download toolchains&#x2F;sources not present on the docs.rs runners, if possible we&#x27;d like to find a way to host our docs on docs.rs.&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 17-10-2022</title>
            <pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-17-10-2022/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-17-10-2022/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q3 2022.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-compiler-llvm&quot;&gt;Rust Compiler &amp;amp; LLVM&lt;&#x2F;h2&gt;
&lt;p&gt;The Rust compiler fork and LLVM have seen a few changes and fixes over the last quarter. Firstly, we have a new way to install the Xtensa-enabled toolchain, introducing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espup&quot;&gt;espup&lt;&#x2F;a&gt;. espup is a new Rust-based installer that replaces the unwieldy bash scripts we were previously using; we&#x27;re still maintaining those for the time being but the future will be espup.&lt;&#x2F;p&gt;
&lt;p&gt;A few issues have been spotted in the last quarter, the first related to the alignment of 128bit arguments on the Xtensa arch which caused &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;137&quot;&gt;#137&lt;&#x2F;a&gt; &amp;amp; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;135&quot;&gt;#135&lt;&#x2F;a&gt;. The second was a loop miscompilation issue in the code generated by the LLVM backend which caused &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;134&quot;&gt;#134&lt;&#x2F;a&gt; &amp;amp; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;127&quot;&gt;#127&lt;&#x2F;a&gt;. This has now been fixed in LLVM and will be released with Rust 1.65.0. Finally, there are some code generation issues around printing floats which can be seen in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;136&quot;&gt;#136&lt;&#x2F;a&gt;, this is an ongoing issue that I haven&#x27;t gotten to the bottom of.&lt;&#x2F;p&gt;
&lt;p&gt;Lastly, we have some progress to report on the LLVM Xtensa upstreaming - it&#x27;s moving! Eight of the ten initial patches have been approved thanks to some new reviewing effort upstream. Since then Cadence (the IP holder for Xtensa) has publically released &lt;a href=&quot;https:&#x2F;&#x2F;www.cadence.com&#x2F;content&#x2F;dam&#x2F;cadence-www&#x2F;global&#x2F;en_US&#x2F;documents&#x2F;tools&#x2F;ip&#x2F;tensilica-ip&#x2F;isa-summary.pdf&quot;&gt;an ISA summary&lt;&#x2F;a&gt; which is fantastic news for the open source community in general but especially us as there is now an official document that reviewers can use to review our backend. We started &lt;a href=&quot;https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-request-for-upstream-tensilica-xtensa-esp32-backend&#x2F;65355&#x2F;3&quot;&gt;a new RFC&lt;&#x2F;a&gt; to finally get the initial patches merged upstream.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-bare-metal&quot;&gt;esp-hal &amp;amp; bare metal&lt;&#x2F;h2&gt;
&lt;p&gt;esp-hal development has been coming along nicely! We even released our first and second releases during this quarter, which is quite the milestone as we now believe that the HAL is in a good enough spot for it to be experimented with.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Very basic support for running applications on the other core &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;96&quot;&gt;#96&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;ADC support &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;97&quot;&gt;#97&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;98&quot;&gt;#98&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Allow for configuring the UART &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;99&quot;&gt;#99&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;102&quot;&gt;#102&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Vectored interrupts &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;103&quot;&gt;#103&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;118&quot;&gt;#118&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Direct-boot support for the ESP32-S3 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;107&quot;&gt;#107&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;CPU clock settings &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;110&quot;&gt;#110&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;111&quot;&gt;#111&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;LEDC support &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;114&quot;&gt;#114&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Critical section implementations &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;151&quot;&gt;#151&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;embedded_hal@1.0.0-alpha.x&lt;&#x2F;code&gt; traits implemented for most peripherals (multiple PRs)&lt;&#x2F;li&gt;
&lt;li&gt;A large number of bug fixes, smaller features, refactoring, etc. (multiple PRs)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;esp-wifi&quot;&gt;esp-wifi&lt;&#x2F;h2&gt;
&lt;p&gt;esp-wifi has had a lot of attention in the last quarter, plenty of fixes and improvements to make it more reliable, as well as adding new target support!&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Remove global allocator &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;73&quot;&gt;#73&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Reduce project size by using size optimized WiFi blobs &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;66&quot;&gt;#66&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Switch the Bluetooth stack to bleps &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;65&quot;&gt;#65&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add WiFi support for the ESP32-S2 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;62&quot;&gt;#62&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add WiFi support for the ESP32-S3 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;55&quot;&gt;#55&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Remove bespoke code in favour of relying on esp-hal where possible (multiple PRs)&lt;&#x2F;li&gt;
&lt;li&gt;Fix order of magnitude timestamp creation error &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;44&quot;&gt;#44&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;esp-storage&quot;&gt;esp-storage&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-storage&quot;&gt;esp-storage&lt;&#x2F;a&gt; is a new crate that implements the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;embedded-storage&#x2F;latest&#x2F;embedded_storage&#x2F;&quot;&gt;embedded-storage&lt;&#x2F;a&gt; traits for Espressif chips. This is useful for writing data to internal flash, which could be paired up with flash aware filesystem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;Espflash has seen some great improvements over the last quarter. We&#x27;re building up to a 2.0 release soon which will feature a much improved, and importantly, consistent CLI.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Support for ESP32-C2 added &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;204&quot;&gt;#204&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Support for using stub loaders added &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;216&quot;&gt;#216&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Improved support for ESP-IDF partition tables (multiple PRs)&lt;&#x2F;li&gt;
&lt;li&gt;Support for flashing the ESP32-S2 via CDC UART &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;228&quot;&gt;#228&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Support for erasing OTA data &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;229&quot;&gt;#229&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Support flashing via the built-in UART peripherals on Raspberry Pi &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;234&quot;&gt;#234&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Relicensed under MIT&#x2F;Apache-2.0 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;235&quot;&gt;#235&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;CLI interface redesign &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;239&quot;&gt;#239&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;A large number of bug fixes, smaller features, refactoring, etc. (multiple PRs)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;rust-flasher-stub&quot;&gt;Rust flasher stub&lt;&#x2F;h3&gt;
&lt;p&gt;Flashing stubs are small programs that the flashing tool uploads to the chip to improve the features or speed of flashing. The stubs available for Espressif chips are currently written in C and can be found &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esptool&#x2F;tree&#x2F;master&#x2F;flasher_stub&quot;&gt;here&lt;&#x2F;a&gt;. These stubs have grown organically over the years and we&#x27;ve wanted to rewrite them for a while. We took this opportunity to write them in Rust! You can find the project &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-flasher-stub&quot;&gt;here&lt;&#x2F;a&gt;, which currently only has a stub for the esp32c3, but esp32 support is being worked on. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;wokwi&quot;&gt;Wokwi&lt;&#x2F;h3&gt;
&lt;p&gt;Wokwi now has in-browser support for building Rust applications for Espressif chips. Check out &lt;a href=&quot;https:&#x2F;&#x2F;wokwi.com&#x2F;rust&quot;&gt;wokwi.com&#x2F;rust&lt;&#x2F;a&gt; and play around with some examples in the comfort of your browser!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;wokwi-server&quot;&gt;wokwi-server&lt;&#x2F;a&gt;, the cargo runner for running applications in Wokwi has been updated to &lt;code&gt;v0.2.0&lt;&#x2F;code&gt;. This includes bumping Tokio to the latest stable and providing prebuilt binaries on the releases page.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;espressif-devcon-2022&quot;&gt;Espressif DevCon 2022 &lt;!-- Link to my talk &amp; Juraj&#x27;s &amp; Uri&#x27;s --&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Espressif is excited to be hosting our first-ever conference this year! It&#x27;s a two-day event starting on the 19th of October! I will be talking about Rust at Espressif along with some of my colleagues. Be sure to register &lt;a href=&quot;https:&#x2F;&#x2F;devcon.espressif.com&#x2F;&quot;&gt;here&lt;&#x2F;a&gt; then drop in and say hi!&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;19th October 13:05 CEST - Rust on Espressif Chips - Scott Mabin&lt;&#x2F;li&gt;
&lt;li&gt;19th October 14:30 CEST - Your browser is ESP32 - Uri Shaked&lt;&#x2F;li&gt;
&lt;li&gt;20th October 16:45 CEST - Paradigm Shift to Cloud-Based Embedded Development - Juraj Michálek, Sergio Gasquez&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Continue to improve the Rust Xtensa fork, and push for LLVM upstreaming, maybe we&#x27;ll see Xtensa (as an experimental target) in upstream Rust sooner than we thought! On a side note, we&#x27;ve started an &amp;quot;awesome&amp;quot; list of awesome esp rust things - check it out &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;awesome-esp-rust&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 15-07-2022</title>
            <pubDate>Fri, 15 Jul 2022 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-15-07-2022/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-15-07-2022/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q2 2022.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;standard-library&quot;&gt;Standard library&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;117&quot;&gt;esp-rs&#x2F;rust#117&lt;&#x2F;a&gt;, failure to list file directories, has been fixed. This issue was two in one; the first applied to any filesystem, used through the &lt;code&gt;libc&lt;&#x2F;code&gt; API. The definition of the &lt;code&gt;dirent&lt;&#x2F;code&gt; structure was incorrect in &lt;code&gt;esp-idf&lt;&#x2F;code&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-idf&#x2F;blob&#x2F;73be74fd71aeec03a972cfe0a9b2f19edc8ea3fa&#x2F;components&#x2F;newlib&#x2F;platform_include&#x2F;sys&#x2F;dirent.h#L45&quot;&gt;this &lt;code&gt;int&lt;&#x2F;code&gt; definition&lt;&#x2F;a&gt; should have been a &lt;code&gt;ino_t&lt;&#x2F;code&gt; definition. The size difference between the two types meant that the name ended up with a null terminator at the beginning, hence no output would be printed when listing a directory. The second part was specific to SPIFFS (a flash-based filesystem), listing a directory would emit an internal error number, which was interpreted as a real error, but in reality, was just a signal that the end of the listing had been reached. More details &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pellepl&#x2F;spiffs&#x2F;pull&#x2F;288&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-hal-bare-metal-support&quot;&gt;esp-hal &amp;amp; bare-metal support&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&quot;&gt;esp-hal&lt;&#x2F;a&gt; has seen much development in the last quarter.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Add a serial driver for the USB-SERIAL-JTAG peripheral - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;56&quot;&gt;esp-hal#56&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add RMT output support, with a implementation for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smart-leds-rs&quot;&gt;smart-leds-rs&lt;&#x2F;a&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;53&quot;&gt;esp-hal#53&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Use &lt;code&gt;fugit&lt;&#x2F;code&gt; time types in the HALs public API - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;64&quot;&gt;esp-hal#64&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for the &lt;code&gt;SYSTIMER&lt;&#x2F;code&gt; on the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, &lt;code&gt;esp32s2&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp32s3&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;76&quot;&gt;esp-hal#76&lt;&#x2F;a&gt; &lt;&#x2F;li&gt;
&lt;li&gt;Add &lt;code&gt;ClockConfig&lt;&#x2F;code&gt; to start to support customizing the chip clocks - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;77&quot;&gt;esp-hal#77&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for most &lt;code&gt;embedded-hal&lt;&#x2F;code&gt; alpha traits - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;82&quot;&gt;esp-hal#82&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add basic EFUSE reading support - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;85&quot;&gt;esp-hal#85&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add DAC peripheral support - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;92&quot;&gt;esp-hal#92&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add ADC peripheral support - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;97&quot;&gt;esp-hal#97&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;98&quot;&gt;esp-hal#98&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for using the second core on the &lt;code&gt;esp32&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp32s3&lt;&#x2F;code&gt; - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;pull&#x2F;96&quot;&gt;esp-hal#96&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;wifi-bluetooth&quot;&gt;WiFi &amp;amp; Bluetooth&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&quot;&gt;esp-wifi&lt;&#x2F;a&gt; has been moved to the esp-rs organization. We now also have support for WiFi on the Xtensa based &lt;code&gt;esp32&lt;&#x2F;code&gt; which was implemented in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;4&quot;&gt;esp-rs&#x2F;esp-wifi#4&lt;&#x2F;a&gt;. The radios inside the &lt;code&gt;esp32&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp32c3&lt;&#x2F;code&gt; also support Bluetooth Low Energy, which has now been implemented for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;30&quot;&gt;esp-rs&#x2F;esp-wifi#30&lt;&#x2F;a&gt; &amp;amp; the &lt;code&gt;esp32&lt;&#x2F;code&gt; in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-wifi&#x2F;pull&#x2F;34&quot;&gt;esp-rs&#x2F;esp-wifi#34&lt;&#x2F;a&gt;, which is very exciting! esp-wifi is still experimental, so do expect some issues but it&#x27;s in a good enough state that &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bjoernQ&quot;&gt;bjoernQ&lt;&#x2F;a&gt; rewrote &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bjoernQ&#x2F;esp32-rust-nostd-temperature-logger&quot;&gt;his temperature logging project&lt;&#x2F;a&gt; using bare metal Rust!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;async-support&quot;&gt;Async support&lt;&#x2F;h3&gt;
&lt;p&gt;On top of the PR&#x27;s listed above, we have begun working on &lt;code&gt;async&lt;&#x2F;code&gt; support too! The go-to embedded executor right now is &lt;a href=&quot;https:&#x2F;&#x2F;embassy.dev&#x2F;&quot;&gt;embassy&lt;&#x2F;a&gt;, which only supported ARM until we recently added support for RISC-V in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy&#x2F;pull&#x2F;804&quot;&gt;embassy#804&lt;&#x2F;a&gt; &amp;amp; support for Xtensa in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy&#x2F;pull&#x2F;805&quot;&gt;embassy#805&lt;&#x2F;a&gt;. The next step is to add an &lt;code&gt;embassy::time::Driver&lt;&#x2F;code&gt; implementation inside esp-hal after which we could create the most basic embassy demo, running on an esp32c3! What&#x27;s nice about this is you get power savings for free, as soon as there are no other tasks or interrupts to process the chip goes to sleep until the next wake-up.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EXECUTOR&lt;&#x2F;span&gt;&lt;span&gt;: Forever&amp;lt;Executor&amp;gt; = Forever::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv_rt&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;entry&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p = esp32c3_hal::embassy::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; executor = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EXECUTOR&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;put&lt;&#x2F;span&gt;&lt;span&gt;(Executor::new());
&lt;&#x2F;span&gt;&lt;span&gt;    executor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spawner&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;        spawner.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;run1&lt;&#x2F;span&gt;&lt;span&gt;()).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        spawner.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;run2&lt;&#x2F;span&gt;&lt;span&gt;()).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;embassy&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;run1&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        esp_println::println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Hello world from embassy on an esp32c3!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;        Timer::after(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;embassy&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;run2&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        esp_println::println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Bing!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;        Timer::after(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3000&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which results in the following output: &lt;&#x2F;p&gt;
&lt;script id=&quot;asciicast-500857&quot; src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;500857.js&quot; async&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Async support is not merged yet, but hopefully by next quarter we have something usable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;In the last quarter we released versions &lt;code&gt;1.4.0&lt;&#x2F;code&gt;, &lt;code&gt;1.4.1&lt;&#x2F;code&gt;, &lt;code&gt;1.5.0&lt;&#x2F;code&gt;, &lt;code&gt;1.5.1&lt;&#x2F;code&gt; and &lt;code&gt;1.6&lt;&#x2F;code&gt; of espflash which includes these changes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Release artifacts built for additional targets, installable via cargo-binstall&lt;&#x2F;li&gt;
&lt;li&gt;Update the --merge option of the save-image subcommand to behave in a more expected way - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;160&quot;&gt;esp-rs&#x2F;espflash#160&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fixes a bug when passing multiple features, causing them to be improperly processed - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;162&quot;&gt;esp-rs&#x2F;espflash#162&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Fix a bug where the RTC watchdog timer was not disabled on reset when using USB Serial JTAG, resulting in flashing failures - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;169&quot;&gt;esp-rs&#x2F;espflash#169&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add a partition-table subcommand that allows conversion between CSV&#x2F;binary and viewing of partition tables on the command-line - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;172&quot;&gt;esp-rs&#x2F;espflash#172&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for flashing from WSL2 (no support for USB Serial JTAG) - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;179&quot;&gt;esp-rs&#x2F;espflash#179&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Detect the bootloader and partition table from ESP-IDF when able - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;186&quot;&gt;esp-rs&#x2F;espflash#186&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add write-bin-to-flash subcommand - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;194&quot;&gt;esp-rs&#x2F;espflash#194&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Add support for flashing the ESP32-C2 (aka ESP8684) - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;204&quot;&gt;esp-rs&#x2F;espflash#204&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;probe-rs&quot;&gt;probe-rs&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;noppej&quot;&gt;@noppej&lt;&#x2F;a&gt; has been doing some fantastic work improving RISC-V support in probe-rs, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;probe-rs&#x2F;probe-rs&#x2F;pull&#x2F;1129&quot;&gt;the first big PR&lt;&#x2F;a&gt; has already been merged, and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;probe-rs&#x2F;probe-rs&#x2F;pull&#x2F;1147&quot;&gt;part two&lt;&#x2F;a&gt; is in review. These changes are huge, making debugging &amp;amp; producing usable stack traces viable on the RISC-V platform, which is handy for the &lt;code&gt;esp32c&lt;&#x2F;code&gt;-series which are all RISC-V based. I hope by the end of the year we would have some basic support for Xtensa too, but there is quite a bit of work to do there.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wokwi-server&quot;&gt;wokwi-server&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wokwi.com&#x2F;&quot;&gt;&lt;code&gt;wokwi&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is an online simulator for IoT projects, it supports many chips including most Espressif ones, the &lt;code&gt;esp32&lt;&#x2F;code&gt;, &lt;code&gt;esp32s2&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp32c3&lt;&#x2F;code&gt;. By default, Wokwi provides an Arduino-like IDE in the browser which handles compilation and then runs the program in the browser simulator. What&#x27;s cool is that Wokwi also exposes a GDB stub that can be used to debug applications, a task that can be very tricky to set up on real hardware.&lt;&#x2F;p&gt;
&lt;p&gt;Rust support (compilation in the browser) is ongoing but not ready for general use just yet, however, there is another way to use Wokwi for Rust development. Introducing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;wokwi-server&quot;&gt;&lt;code&gt;wokwi-server&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, a way to build an application locally and then run it in the browser - no hardware required! See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;wokwi-server#as-a-cargo-runner&quot;&gt;cargo runner section&lt;&#x2F;a&gt; of the README for details. Once set up, a &lt;code&gt;cargo run&lt;&#x2F;code&gt; invocation is all you need.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;esp-backtrace-esp-println-esp-alloc&quot;&gt;esp-backtrace, esp-println &amp;amp; esp-alloc&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-println&quot;&gt;esp-println&lt;&#x2F;a&gt; provides &lt;code&gt;print!&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;println!&lt;&#x2F;code&gt; macros for all Espressif chips currently supported, as well as a &lt;code&gt;log::Log&lt;&#x2F;code&gt; implementation too. It is a standalone crate with no dependencies (uses the ROM functions burned into the chip at the factory). &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-backtrace&quot;&gt;esp-backtrace&lt;&#x2F;a&gt; is a crate for generating backtraces &lt;em&gt;on the chip&lt;&#x2F;em&gt; which supports all the printing methods esp-println does. We currently have support for generating Xtensa &amp;amp; RISC-V backtraces which cover all Espressif chips. We also created &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-alloc&quot;&gt;esp-alloc&lt;&#x2F;a&gt; which provides a bare metal allocator for all Espressif chips.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;devcontainer-support&quot;&gt;Devcontainer support&lt;&#x2F;h3&gt;
&lt;p&gt;Both the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-template&quot;&gt;esp-idf-template&lt;&#x2F;a&gt; &amp;amp; the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-template&quot;&gt;esp-template&lt;&#x2F;a&gt; repositories now have &lt;code&gt;cargo-generate&lt;&#x2F;code&gt; options to configure Devcontainers. It&#x27;s as simple as filling in the options when cloning the template with &lt;code&gt;cargo-generate&lt;&#x2F;code&gt; and you can have a functioning esp rust environment immediately, with all the tooling ready to go!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;esp-rust-board&quot;&gt;esp rust board&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-rust-board&quot;&gt;esp rust board&lt;&#x2F;a&gt; is now available for purchase! You can find purchase links on &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;devkits&quot;&gt;the Espressif website&lt;&#x2F;a&gt;, it is listed as &lt;code&gt;ESP32-C3-DevKit-RUST-1&lt;&#x2F;code&gt;. Unfortunately, it sold out pretty quickly but the next batch should be available around mid-August.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ferrous-systems-training&quot;&gt;Ferrous systems training&lt;&#x2F;h2&gt;
&lt;p&gt;Tickets to &lt;a href=&quot;https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;announce-esp-training&#x2F;&quot;&gt;the Ferrous training&lt;&#x2F;a&gt; based on the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; are now available too, check out the options &lt;a href=&quot;https:&#x2F;&#x2F;ferrous-systems.com&#x2F;training&#x2F;#package-espressif-beginner-training&quot;&gt;here&lt;&#x2F;a&gt;. Booking the training includes an &lt;code&gt;ESP32-C3-DevKit-RUST-1 board&lt;&#x2F;code&gt; as part of the package so no need to worry about acquiring one yourself.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Continue the rapid progress on the bare metal multi-chip HAL, &lt;code&gt;esp-hal&lt;&#x2F;code&gt;, including the new &lt;code&gt;async&lt;&#x2F;code&gt; effort. Improve the stability of &lt;code&gt;esp-wifi&lt;&#x2F;code&gt;. Continue support of our Standard library port, &lt;code&gt;esp-idf&lt;&#x2F;code&gt; version 5.0 is nearly here and has some breaking changes that we&#x27;ll need to handle in &lt;code&gt;libc&lt;&#x2F;code&gt; and our &lt;code&gt;esp-idf&lt;&#x2F;code&gt; crates.&lt;&#x2F;p&gt;
&lt;p&gt;As a final note, we are seeing a big influx of community pull requests, which is great to see! Thank you to all those who have contributed so far! :)&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 04-04-2022</title>
            <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-04-04-2022/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-04-04-2022/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q1 2022.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;standard-library&quot;&gt;Standard library&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;build-system-changes&quot;&gt;Build system changes&lt;&#x2F;h3&gt;
&lt;p&gt;The last post mentioned we were moving towards using the built-in esp-idf build system to compile esp-idf (dubbed &amp;quot;native&amp;quot; build) instead of PlatformIO. I&#x27;m happy to announce we have completed this step, going forward the native approach is the default, and platformIO is opt-in via the &lt;code&gt;pio&lt;&#x2F;code&gt; feature of &lt;code&gt;esp-idf-sys&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;new-default-version&quot;&gt;New default version&lt;&#x2F;h3&gt;
&lt;p&gt;The default esp-idf version we target in the Rust world was v4.3 (note that this can be configured on a per-project basis), we have now bumped this to now default to v4.4. Version 4.4 has some quality of life fixes, as well as some features.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Atomic Emulation up to 64 bits for &lt;code&gt;espidf&lt;&#x2F;code&gt; targets - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;107&quot;&gt;esp-rs&#x2F;rust#107&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;A &lt;code&gt;realpath&lt;&#x2F;code&gt; implementation to get usable panic messages for &lt;code&gt;espidf&lt;&#x2F;code&gt; targets.&lt;&#x2F;li&gt;
&lt;li&gt;Toolchain update to support developing on Windows - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-idf&#x2F;issues&#x2F;7864&quot;&gt;espressif&#x2F;esp-idf#7864&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;compiler-xtensa-code-generation&quot;&gt;Compiler &amp;amp; Xtensa code generation&lt;&#x2F;h3&gt;
&lt;p&gt;Rust has been a good stress test for the Xtensa LLVM backend. We&#x27;ve spotted a few bugs over the last quarter which are important to squash as eventually esp-idf will be compiled with clang instead of GCC (Hopefully by that time, &lt;code&gt;clang&lt;&#x2F;code&gt; will be available as a &lt;code&gt;rustup&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;56371&quot;&gt;component&lt;&#x2F;a&gt;). We have also fixed a few issues with our standard library port.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;LLVM compilation error when optimizing loops for the hardware loop assistance registers of the esp32 - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;95&quot;&gt;esp-rs&#x2F;rust#95&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;LLVM atomic swap code generation broken on Xtensa targets for atomics smaller than 32 bits - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;106&quot;&gt;esp-rs&#x2F;rust#106&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Add implementations for &lt;code&gt;lstat&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;ftruncate&lt;&#x2F;code&gt; in esp-idf - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;100&quot;&gt;esp-rs&#x2F;rust#100&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Fix the size of certain c types for &lt;code&gt;espidf&lt;&#x2F;code&gt; targets such that &lt;code&gt;stat&lt;&#x2F;code&gt; works correctly - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;92&quot;&gt;esp-rs&#x2F;rust#92&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bare-metal&quot;&gt;Bare metal&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;goodbye-esp-rs-esp32-hal-hello-esp-rs-esp-hal&quot;&gt;Goodbye esp-rs&#x2F;esp32-hal, hello esp-rs&#x2F;esp-hal&lt;&#x2F;h3&gt;
&lt;p&gt;The new &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&quot;&gt;esp-hal&lt;&#x2F;a&gt; is coming along very well, it already has support for GPIO, TIMG, UART, I2C, SPI, and RNG for esp32, esp32s2, esp32s3, and esp32c3. Please see &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-hal&#x2F;issues&#x2F;19&quot;&gt;this tracking issue&lt;&#x2F;a&gt; to see the chip support status. This multi-chip HAL is now using the official SVDs from Espressif instead of the hacked together SVD used in the original esp32 peripheral access crate (PAC), see the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-pacs&quot;&gt;esp-rs&#x2F;esp-pacs&lt;&#x2F;a&gt; repository. We&#x27;ve added a quick start template repository &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-template&quot;&gt;esp-rs&#x2F;esp-template&lt;&#x2F;a&gt; to get started with the new bare metal HAL.&lt;&#x2F;p&gt;
&lt;p&gt;The original HAL for the esp32 is now in maintenance mode, and will soon be deprecated once all drivers are ported to the new multi-chip HAL. There is still a number of drivers to be ported to the new HAL. Porting them would be a good first issue for anyone interested as the implementation would mostly stay the same, just a few API &amp;amp; type changes. Please see &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;issues&#x2F;80&quot;&gt;this issue&lt;&#x2F;a&gt; if you want to help out.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preliminary-wifi-support&quot;&gt;Preliminary WiFi support&lt;&#x2F;h3&gt;
&lt;p&gt;This is something I&#x27;m personally very excited about. We&#x27;ve had WiFi support for the standard library (&lt;code&gt;espidf&lt;&#x2F;code&gt;) targets for a long while now, but just recently we&#x27;ve managed to get WiFi going in pure Rust&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;! It&#x27;s possible to &lt;code&gt;scan&lt;&#x2F;code&gt; for Access Points (APs) and connect to an AP, and use &lt;code&gt;smoltcp&lt;&#x2F;code&gt; to talk over the network! Check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bjoernQ&#x2F;esp32c3-wifi-rs&#x2F;blob&#x2F;main&#x2F;examples&#x2F;dhcp.rs&quot;&gt;dhcp example&lt;&#x2F;a&gt;. The repository is currently in a proof of concept state and can be found &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bjoernQ&#x2F;esp32c3-wifi-rs&quot;&gt;here&lt;&#x2F;a&gt;. It will be moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; org once we clean it up and add xtensa support.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h3&gt;
&lt;p&gt;Since the last post we have released 1.3.0 and the 1.4.0 release is due to be published very soon which boasts some great features and fixes.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Better partition table support. We now properly handle partitions other than &lt;code&gt;factory&lt;&#x2F;code&gt; (OTA, etc).&lt;&#x2F;li&gt;
&lt;li&gt;USB Serial JTAG support. It&#x27;s now possible to flash over the serial part of onboard the USB Serial JTAG peripheral.&lt;&#x2F;li&gt;
&lt;li&gt;The ability to modify firmware header via the command line. Configure custom flash sizes, flash speeds, and flash modes.&lt;&#x2F;li&gt;
&lt;li&gt;Use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espmonitor&quot;&gt;&lt;code&gt;espmonitor&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as the &lt;code&gt;--monitor&lt;&#x2F;code&gt; inside &lt;code&gt;espflash&lt;&#x2F;code&gt;. &lt;code&gt;espmonitor&lt;&#x2F;code&gt; can decode addresses to source functions, providing a stack trace on abort over the serial port.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;github-actions&quot;&gt;Github actions&lt;&#x2F;h3&gt;
&lt;p&gt;Want to test your Xtensa based projects in CI? We recently released &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-toolchain&quot;&gt;xtensa-toolchain&lt;&#x2F;a&gt;, a Github action for installing our forked Rust compiler with Xtensa support. Instructions on how to use can be found &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marketplace&#x2F;actions&#x2F;rust-toolchain-for-xtensa&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;esp-rs-devcontainer-for-visual-studio-code&quot;&gt;esp-rs devcontainer for Visual Studio Code&lt;&#x2F;h3&gt;
&lt;p&gt;To target Xtensa based chips (esp32, esp32s2, esp32s3, etc) we need a custom rust compiler, with a custom LLVM backend for Xtensa. This adds some friction to getting started with Xtensa based chips. We &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust-build&quot;&gt;already offer scripts&lt;&#x2F;a&gt; to download pre-built compiler toolchains, but we are happy to announce &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SergioGasquez&#x2F;esp-rs-devcontainer&quot;&gt;esp-rs-devcontainer&lt;&#x2F;a&gt;. This integrates into Visual Studio Code using the remote containers feature, allowing easy setup for developers already familiar with containers. Please see the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SergioGasquez&#x2F;esp-rs-devcontainer#setup&quot;&gt;setup section&lt;&#x2F;a&gt; for supported configurations and initialization steps.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;community&quot;&gt;Community&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-esp-rust-board&quot;&gt;The ESP Rust Board&lt;&#x2F;h3&gt;
&lt;p&gt;We&#x27;ve developed an open source development board with a focus on being ready for Rust development! It&#x27;s based on the RISCV esp32c3, so a standard Rust compiler will work. Whilst the boards are not yet on sale, the source files are available &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-rust-board&quot;&gt;here&lt;&#x2F;a&gt; if you want to build one yourself.&lt;&#x2F;p&gt;
&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;rust_board_v1_pin-layout.png&quot;&#x2F;&gt;
&lt;h3 id=&quot;ferrous-training&quot;&gt;Ferrous training&lt;&#x2F;h3&gt;
&lt;p&gt;We have collaborated with Ferrous Systems to produce a training workshop to help teach developers how to get productive with Rust on Espressif chips! Please see the &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;news&#x2F;ESP_RUST_training&quot;&gt;newsletter release&lt;&#x2F;a&gt; for the full details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Continue the rapid progress on the bare metal multi-chip HAL, &lt;code&gt;esp-hal&lt;&#x2F;code&gt; and add bare metal WiFi support for Xtensa chips. The esp-idf series of crates are starting to stabilize however, there are still plenty of drivers and libraries not yet covered by nice Rust abstractions, so lots still to do here!&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;The WiFi binary blobs are not written in Rust&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 10-01-2022</title>
            <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-10-01-2022/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-10-01-2022/</guid>
            <description>&lt;p&gt;This is the next quarterly update of esp-rs effort, detailing the progress over Q4 2021.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;documentation&quot;&gt;Documentation&lt;&#x2F;h2&gt;
&lt;p&gt;Feedback we have received over the last quarter has primarily been about documentation, or lack there of. We&#x27;ve been working hard on this, making multiple contributions to &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;the book&lt;&#x2F;a&gt; ourselves, as well as some community contributions too. We&#x27;re also working on documentation for the &lt;code&gt;esp-idf-*&lt;&#x2F;code&gt; based crates required for using the standard library; because the build process currently requires an internet connection to download esp-idf sources it&#x27;s not possible to host the docs on &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&quot;&gt;docs.rs&lt;&#x2F;a&gt;. I&#x27;ve recently opened &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-sys&#x2F;pull&#x2F;50&quot;&gt;a PR to self host the documentation&lt;&#x2F;a&gt; until we can figure out a vendoring solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;standard-library&quot;&gt;Standard library&lt;&#x2F;h2&gt;
&lt;p&gt;Bug fixes and incremental improvements to the standard library port have been rolling in. We have also been working on a new build approach, dubbed the &amp;quot;native&amp;quot; build. To explain why we are trying to switch the native build, I&#x27;ll explain how it currently works. The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;embuild&quot;&gt;embuild&lt;&#x2F;a&gt; project manages the download of sources, tools and patches before generating bindings and compiling the esp-idf project ready for use with Rust. The build step initially started using &lt;a href=&quot;https:&#x2F;&#x2F;platformio.org&#x2F;&quot;&gt;platformIO&lt;&#x2F;a&gt; (PIO) to build esp-idf, which worked great, there are a few caveats to this approach. PIO lags behind in chip support, for example with the new native approach the esp32s3 is now supported, however PIO does not yet support this. The new native approach uses esp-idf&#x27;s native cmake build system, specifically the cmake file APIs to interact and build esp-idf ready for use in Rust. This has the added advantage that we have control of both sides of the build process and can consider changes in esp-idf to make using it with Rust easier.&lt;&#x2F;p&gt;
&lt;p&gt;One common question we receive is regarding the esp8266 and why there is no standard library support (please note that there &lt;strong&gt;is&lt;&#x2F;strong&gt; decent support for the esp8266 with bare metal Rust (no_std)). Unfortunately esp-idf does not support the esp8266, and instead is supported &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;ESP8266_RTOS_SDK&quot;&gt;a different project&lt;&#x2F;a&gt;. It is very possible to run the standard library on the esp8266, but will require some work implementing support like we did for esp-idf. It may be easier to add support for the esp8266 to esp-idf but we don&#x27;t have any plans of doing any of this at the moment.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bare-metal&quot;&gt;Bare metal&lt;&#x2F;h2&gt;
&lt;p&gt;The bare metal story has been a little quiet over the last quarter, with the main focus on the standard library effort &amp;amp; tooling. However, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; has started work on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&#x2F;esp-hal&quot;&gt;esp-hal&lt;&#x2F;a&gt; which is set to be a combined bare metal HAL for Espressif chips! It&#x27;s in very early stages but already has a GPIO driver for the esp32 &amp;amp; esp32c3. Contributions are most welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;atomic-story-for-the-esp32c3-no-std&quot;&gt;Atomic story for the esp32c3 (no_std)&lt;&#x2F;h2&gt;
&lt;p&gt;In the last post I mentioned we were working on an atomic trap handler to emulate atomics for the esp32c3 for bare metal projects. We have now released it &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;riscv-atomic-emulation-trap&quot;&gt;under our Github organization&lt;&#x2F;a&gt; and it&#x27;s very simple to use, simply include this line in your application:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use&lt;&#x2F;span&gt;&lt;span&gt; riscv_atomic_emulation_trap as _;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It integrates seamlessly with the &lt;code&gt;riscv_rt&lt;&#x2F;code&gt; crate, meaning any other exceptions, or instructions that can&#x27;t be emulated are pushed to the &lt;code&gt;riscv_rt&lt;&#x2F;code&gt; exception handler. Last but by no means least, this will work for &lt;strong&gt;any&lt;&#x2F;strong&gt; RISC-V chip without atomic support&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;! Not just Espressif chips.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;probe-rs&quot;&gt;probe-rs&lt;&#x2F;h2&gt;
&lt;p&gt;probe-rs support for the esp32c3 is relatively complete now. Most excitingly &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Yatekii&quot;&gt;@Yatekii&lt;&#x2F;a&gt; wrote a driver for the on die USB JTAG peripheral inside the esp32c3! Meaning it&#x27;s possible to flash and debug a esp32c3 (and upcoming chips...) with just a USB cable! Best part is that all our fixes and changes have made it into the v0.14 release of probe-rs, so with the latest version installed you&#x27;re ready to debug &amp;amp; program a esp32c3! More details in the &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;the book&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;espflash&quot;&gt;espflash&lt;&#x2F;h2&gt;
&lt;p&gt;espflash has seen a few minor releases since its 1.0 release in the last post, in which the following features and fixes have been included:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CLI argument parsing was unified between &lt;code&gt;cargo-espflash&lt;&#x2F;code&gt; and &lt;code&gt;espflash&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;Same subcommands and arguments available for both binaries (minus the build-related stuff for &lt;code&gt;espflash&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Support added for flashing the ESP32-S3&lt;&#x2F;li&gt;
&lt;li&gt;Serial port auto-detection implemented
&lt;ul&gt;
&lt;li&gt;Optionally allows for a VID&#x2F;PID to be specified via config file&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Various bugfixes and improvements:
&lt;ul&gt;
&lt;li&gt;Add &lt;code&gt;--package&lt;&#x2F;code&gt; and &lt;code&gt;--target&lt;&#x2F;code&gt; options&lt;&#x2F;li&gt;
&lt;li&gt;Retry connections with different delays (for older ESP32 chips)&lt;&#x2F;li&gt;
&lt;li&gt;Improved handling of custom partition tables&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;compiler&quot;&gt;Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;There is little to report on the compiler front, the main addition is the esp32s3 bare metal and std target. However, using Rust has been a great test bed for our LLVM fork supporting the Xtensa architecture and it has already brought a few code generation bugs to light which have been promptly fixed with patch releases to the LLVM fork. I&#x27;d also like to reiterate that we have prebuilt toolchains available with Xtensa support under the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust-build&quot;&gt;rust-build&lt;&#x2F;a&gt; repository, it is no longer required to build the compiler yourself. We have builds for:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;x86
&lt;ul&gt;
&lt;li&gt;Windows&lt;&#x2F;li&gt;
&lt;li&gt;Linux&lt;&#x2F;li&gt;
&lt;li&gt;MacOS&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;aarch64
&lt;ul&gt;
&lt;li&gt;MacOS (M1)&lt;&#x2F;li&gt;
&lt;li&gt;Linux&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Our main goal are squashing bugs and documentation improvements. We also would like to start creating some more advanced examples to show off the progress we&#x27;ve made, if you have any projects you&#x27;re working on that please feel free to drop into &lt;a href=&quot;https:&#x2F;&#x2F;matrix.to&#x2F;#&#x2F;#esp-rs:matrix.org&quot;&gt;the matrix chat&lt;&#x2F;a&gt; and tell us all about it! If the project is open source we may also add it to our CI regression test so we (hopefully) won&#x27;t break your project in the future. I&#x27;d also like to take this time to thank all of our community contributors, we&#x27;ve made some awesome progress in the last two quarters thanks to your help!&lt;&#x2F;p&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;This hasn&#x27;t yet been tested on 64bit RISC-V.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;There is some missing tooling on the esp-idf side for Linux aarch64, please &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-sys&#x2F;issues&#x2F;14&quot;&gt;track this issue&lt;&#x2F;a&gt; if you are interested.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips - 18-10-2021</title>
            <pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-18-10-2021/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-18-10-2021/</guid>
            <description>&lt;p&gt;Now I am working at Espressif I plan on publishing updates roughly every quarter just to keep the community in the loop around the esp rust effort.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;documentation-planning&quot;&gt;Documentation &amp;amp; Planning&lt;&#x2F;h2&gt;
&lt;p&gt;One of the hardest parts in any community project is onboarding new developers, especially in the early stages of a project where API&#x27;s, processes and tooling is changing rapidly; it can be frustrating to work on something one week, and in the next you&#x27;re fighting to get it compiling again. We began work on &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;a book&lt;&#x2F;a&gt; in which we will try to keep as a source of truth for the Rust esp effort. This will include install instructions, tooling guides, ecosystem overviews and much more. &lt;&#x2F;p&gt;
&lt;p&gt;We have also put together a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;esp-rs&#x2F;projects&#x2F;1&quot;&gt;road map project&lt;&#x2F;a&gt; on github, with the aim of managing the project from Espressif&#x27;s point of view, but also to allow new contributors to pick up backlog items. Simply comment in the issue if there is something you&#x27;d like to take a stab at, we&#x27;re more than happy to assist and review. We also host bi-weekly meetings which anyone is welcome to attend, just drop a comment &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;discussions&quot;&gt;in the latest discussion thread&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-the-rust-standard-library-on-espressif-chips&quot;&gt;Using the Rust standard library on Espressif chips&lt;&#x2F;h2&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp-rust-espressif&#x2F;&quot;&gt;the last post&lt;&#x2F;a&gt;, I mentioned that was possible to use the Rust standard library thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt;&#x27;s hard work; well, he&#x27;s been at it again! He pushed forward and managed to upstream the standard library changes required to build &lt;code&gt;std&lt;&#x2F;code&gt; on top of &lt;code&gt;esp-idf&lt;&#x2F;code&gt;. From Rust 1.56 it the changes will be stable, meaning it&#x27;s possible to use the upstream Rust toolchain to build the &lt;code&gt;std&lt;&#x2F;code&gt; platform for any RISC-V Espressif chip! Currently, that only includes the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; but there are more to come. This change also applies to Xtensa chips, however they still require a custom toolchain due to the lack of a backend for Xtensa in upstream LLVM. For more info in the &lt;code&gt;std&lt;&#x2F;code&gt; effort, please see &lt;a href=&quot;https:&#x2F;&#x2F;esp-rs.github.io&#x2F;book&#x2F;&quot;&gt;the book&lt;&#x2F;a&gt;. I&#x27;d also like to take this time to thank the upstream Rust developers for the prompt and helpful reviews, in particular &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Amanieu&quot;&gt;@Amanieu&lt;&#x2F;a&gt; for helping us push this over the finish line.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;compiler&quot;&gt;Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;The custom toolchain is a hindrance to developer onboarding, especially if developers have to build it themselves. We now offer a prebuilt toolchain&#x27;s for all common OS&#x27;s under the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust-build&quot;&gt;esp-rs&#x2F;rust-build&lt;&#x2F;a&gt; repository. A few days after a new Rust release we typically have the new compiler ready, unless we run into any issues; speaking of, we now test the compiler with a few projects in CI so hopefully we don&#x27;t ship a broken compiler. Note that this extra compiler step is only required when targeting Espressif&#x27;s Xtensa based chips.&lt;&#x2F;p&gt;
&lt;p&gt;There have been a couple of improvements to the compiler fork since the last post, for one the patch set we have to manage has reduced in size thanks to the &lt;code&gt;std&lt;&#x2F;code&gt; library changes being upstreamed. There is now &lt;code&gt;asm!&lt;&#x2F;code&gt; support for the Xtensa architecture, which also means we have removed the old &lt;code&gt;llvm_asm!&lt;&#x2F;code&gt; macros from the &lt;code&gt;xtensa&lt;&#x2F;code&gt; crates and ported them to the new syntax.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;svds&quot;&gt;SVDs&lt;&#x2F;h3&gt;
&lt;p&gt;SVDs have been coming along very nicely, we now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;svd&#x2F;tree&#x2F;main&#x2F;svd&quot;&gt;have official SVDs&lt;&#x2F;a&gt; for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, &lt;code&gt;esp32s2&lt;&#x2F;code&gt; and the &lt;code&gt;esp32&lt;&#x2F;code&gt;. If you have been following this effort for a while, you may be thinking we already had an &lt;code&gt;esp32&lt;&#x2F;code&gt; SVD, well you would be correct! However, it was very hacky, missed a lot of peripherals and was all around horrible to work with. The new SVD aims to be more complete and importantly more consistent. One thing that has been missing from the official SVDs is interrupt information, however this has recently changed and interrupt information for each peripheral is now available. Overall the SVDs available now are in a great spot to feed into &lt;code&gt;svd2rust&lt;&#x2F;code&gt; and other tooling, ready for HAL creation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;espflash&quot;&gt;&lt;code&gt;espflash&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&quot;&gt;&lt;code&gt;espflash&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a rewrite of Espressif&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esptool&quot;&gt;&lt;code&gt;esptool.py&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, but also has &lt;code&gt;cargo&lt;&#x2F;code&gt; integration. It&#x27;s been under heavy development and now has a &lt;code&gt;1.0&lt;&#x2F;code&gt; release! Including:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Support for flashing:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;esp32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp32c3&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp32s2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;esp8266&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Compression for faster flashing.&lt;&#x2F;li&gt;
&lt;li&gt;Support for the &lt;code&gt;esp-idf&lt;&#x2F;code&gt; partition table format.&lt;&#x2F;li&gt;
&lt;li&gt;Support for flashing a stock &lt;code&gt;esp-idf&lt;&#x2F;code&gt; bootloader.&lt;&#x2F;li&gt;
&lt;li&gt;Removed support &lt;code&gt;xargo&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;cargo xbuild&lt;&#x2F;code&gt;, now focusing support on &lt;code&gt;build-std&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Reading back flash info.&lt;&#x2F;li&gt;
&lt;li&gt;Reading some EFUSE values.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;elf2image&lt;&#x2F;code&gt; functionality, for writing the formatted image to a file.&lt;&#x2F;li&gt;
&lt;li&gt;Beautiful &amp;amp; helpful error messages with &lt;code&gt;miette&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Big thanks to all the contributors in this release, especially &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;probe-rs&quot;&gt;&lt;code&gt;probe-rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;We have also started adding support for flashing and debugging Espressif chips with &lt;code&gt;probe-rs&lt;&#x2F;code&gt;. As the RISC-V architecture is already supported in &lt;code&gt;probe-rs&lt;&#x2F;code&gt;, we set out to add support for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; initially. We are happy to report that &lt;code&gt;probe-rs&lt;&#x2F;code&gt; master now has a flash algorithm capable of flashing the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;! The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-flash-loader&quot;&gt;&lt;code&gt;esp-flash-loader&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; repository contains the code for the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; flash loader, but thanks for Espressif&#x27;s ROM API it should be very easy to port the algorithm to the other chips. Xtensa support for &lt;code&gt;probe-rs&lt;&#x2F;code&gt; is planned eventually, but will take some time to implement. A big thank you to the &lt;code&gt;probe-rs&lt;&#x2F;code&gt; folks, in particular &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Yatekii&quot;&gt;@Yatekii&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Tiwalun&quot;&gt;@Tiwalun&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Dirbaio&quot;&gt;@Dirbaio&lt;&#x2F;a&gt; for the reviews and assistance.&lt;&#x2F;p&gt;
&lt;p&gt;Having &lt;code&gt;probe-rs&lt;&#x2F;code&gt; support gives us easy access to &lt;a href=&quot;https:&#x2F;&#x2F;www.segger.com&#x2F;products&#x2F;debug-probes&#x2F;j-link&#x2F;technology&#x2F;about-real-time-transfer&#x2F;&quot;&gt;RTT&lt;&#x2F;a&gt; for fast, low overhead logging. We have the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; using RTT with &lt;code&gt;probe-rs&lt;&#x2F;code&gt; locally, however a few patches are required due to the &lt;code&gt;esp32c3&lt;&#x2F;code&gt;&#x27;s lack of atomics. Whilst we have contributed to crates such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;atomic-polyfill&#x2F;pull&#x2F;6&quot;&gt;atomic-polyfill&lt;&#x2F;a&gt; these crates are quite intrusive and require other ecosystem crates to depend on them instead of &lt;code&gt;core::sync::atomic&lt;&#x2F;code&gt;. To combat this, we are in the process of writing an atomic emulation trap handler. This works by treating the &lt;code&gt;esp32c3&lt;&#x2F;code&gt; like it has atomic support (build as &lt;code&gt;riscv32imac-unknown-none-elf&lt;&#x2F;code&gt;), and when we trap on the atomic instructions, we decode them and emulate them in software transparently. There is a performance penalty that it is roughly 2-4x slower than native instructions based on our testing, but having an atomic story is important in the embedded Rust ecosystem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Continue to improve the tooling around Rust with Espressif chips, until we have out of the box solutions for most stories. Continue to build and polish standard library use with Espressif chips, as well as the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; story. We would also like to explore using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustc_codegen_gcc&quot;&gt;rustc_codegen_gcc&lt;&#x2F;a&gt; to try and target Espressif&#x27;s Xtensa chips. The end goal will still be to upstream the Xtensa backend to LLVM, but &lt;code&gt;rustc_codegen_gcc&lt;&#x2F;code&gt; may allow targeting Xtensa chips faster as GCC already has a stable Xtensa backend. &lt;&#x2F;p&gt;
&lt;p&gt;Expect another update early next year!&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust on Espressif chips</title>
            <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-espressif/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-espressif/</guid>
            <description>&lt;p&gt;It&#x27;s been a while since my last post. I have some exciting news to share before going over the progress over the last nine months. I will be joining Espressif full time to work on Rust support for all of Espressif&#x27;s chips, past, present and future! I am very excited to join Espressif and improve the Rust ecosystem surrounding their chips!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;organisation&quot;&gt;Organisation&lt;&#x2F;h3&gt;
&lt;p&gt;The forked compiler with esp support has been moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organisation, along with some idf support crates - more on that shortly! &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;discussions&quot;&gt;Discussions&lt;&#x2F;a&gt; have been enabled on the &lt;code&gt;esp-rs&#x2F;rust&lt;&#x2F;code&gt; repository, and for the last month Espressif have been hosting weekly community meetings focusing on pushing Rust support forward. If you&#x27;d like to discuss something and attend, drop a comment in the latest thread and request an invite!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-rust-standard-library-on-espressif-chips&quot;&gt;The Rust standard library on Espressif chips&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; been working very hard on porting the Rust STD library to &lt;code&gt;esp-idf&lt;&#x2F;code&gt;, the C based development environment for Espressif chips. &lt;code&gt;esp-idf&lt;&#x2F;code&gt; has a newlib environment which can be used to build the Rust library on top of. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&quot;&gt;@ivmarkov&lt;&#x2F;a&gt; has put together &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;rust-esp32-std-hello&quot;&gt;rust-esp32-std-hello&lt;&#x2F;a&gt; demo repo to show off the capabilities, which include WiFi, threads and driving a display using the &lt;code&gt;esp-idf&lt;&#x2F;code&gt;&#x27;s drivers. Extremely cool stuff! There are a few teething issues, which you can track &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;rust&#x2F;issues&#x2F;57&quot;&gt;here&lt;&#x2F;a&gt; but hopefully we will be in a position to start upstreaming these patches soon.&lt;&#x2F;p&gt;
&lt;p&gt;To suppliment the standard library for Espressif chips, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-hal&quot;&gt;&lt;code&gt;esp-idf-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has been updated and moved into the &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organisation. This crate has API&#x27;s to use peripherals and hardware that do not have abstractions in the standard library, for example the SPI peripheral. Along with the HAL, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp-idf-svc&quot;&gt;&lt;code&gt;esp-idf-svc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has also been added, which is an implementation of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;embedded-svc&quot;&gt;&lt;code&gt;embedded-svc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; traits for Espressif chips. The goal behind &lt;code&gt;embedded-svc&lt;&#x2F;code&gt; is to provide abstractions around higher level embedded services, WiFi, Ping, HTTPD, NVS etc.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bare-metal&quot;&gt;Bare metal&lt;&#x2F;h3&gt;
&lt;p&gt;Whilst the biggest changes have been around esp standard library developments, bare metal support has not been forgotten! A few months I got my hands on a &lt;code&gt;esp32c3&lt;&#x2F;code&gt;, a &lt;code&gt;RISC-V&lt;&#x2F;code&gt; based chip; because upstream Rust already supports &lt;code&gt;RISC-V&lt;&#x2F;code&gt; putting together a rudimentary bare metal example was &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;esp32c3-experiments&quot;&gt;quite simple&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Blinky program written in &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;rustlang?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#rustlang&lt;&#x2F;a&gt;, running on the RISC-V powered &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;esp32c3?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#esp32c3&lt;&#x2F;a&gt; from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;hashtag&#x2F;espressif?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#espressif&lt;&#x2F;a&gt; . &lt;a href=&quot;https:&#x2F;&#x2F;t.co&#x2F;9qfqZk1WYq&quot;&gt;pic.twitter.com&#x2F;9qfqZk1WYq&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&amp;mdash; Scott Mabin (@mabezzzzz) &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;mabezzzzz&#x2F;status&#x2F;1391500605915607049?ref_src=twsrc%5Etfw&quot;&gt;May 9, 2021&lt;&#x2F;a&gt;&lt;&#x2F;blockquote&gt; &lt;script async src=&quot;https:&#x2F;&#x2F;platform.twitter.com&#x2F;widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Whilst the program above worked, much like &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust&#x2F;&quot;&gt;my first ever post&lt;&#x2F;a&gt; it isn&#x27;t very &amp;quot;Rusty&amp;quot;. Fortunately Espressif have recently release &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;svd&#x2F;tree&#x2F;esp32c3&quot;&gt;a preliminary SVD file for the esp32c3&lt;&#x2F;a&gt;, the first of its kind from Espressif which is super exciting! This means we can feed the SVD into &lt;code&gt;svd2rust&lt;&#x2F;code&gt; (see my other post about doing this for the esp32 &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;) and generate a peripheral access crate (PAC) for the esp32c3 and build abstractions on top of that. With official SVD&#x27;s coming out I hope that we can integrate that into the current bare metal &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&quot;&gt;&lt;code&gt;esp32-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, turning it into a mono repository supporting all of Espressif&#x27;s chips in pure Rust.&lt;&#x2F;p&gt;
&lt;p&gt;It also means I can finally kill off the abomination which is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;&lt;code&gt;idf2svd&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; :D.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h3&gt;
&lt;p&gt;We should be able to start upstreaming some of the RISC-V based changes soon! With official SVD&#x27;s coming out, bare metal esp32 support should start moving forward again too.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust on the ESP32 &amp; ESP8266 - Building an ecosystem</title>
            <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp-rust-ecosystem/</link>
            <guid>https://mabez.dev/blog/posts/esp-rust-ecosystem/</guid>
            <description>&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;last post, nearly 10 months ago&lt;&#x2F;a&gt; a lot has changed. For one, its not just me working on this any more! Community members are starting to contribute to the various ESP related projects. The extra help meant we have made considerable progress which I will now take you through in this post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-compiler&quot;&gt;The compiler&lt;&#x2F;h2&gt;
&lt;p&gt;I have been working on cleaning up the &lt;code&gt;rustc&lt;&#x2F;code&gt; work, including rebasing regularly to keep up with upstream rustc changes. Recently, I have cleaned up and extracted the patches required to enable &lt;code&gt;Xtensa&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;esp&lt;&#x2F;code&gt; development with Rust, firstly to make it easier to rebase onto a newer version of the compiler, but also in the hopes of one day being able to submit these patches upstream when the &lt;code&gt;Xtensa&lt;&#x2F;code&gt; target is upstreamed in llvm. You can see the patchset &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa-patches&quot;&gt;here&lt;&#x2F;a&gt;. On that note, it seems no progress has been made on that front in the last 9 months; whilst Espressif are doing a great job responding to issues and fixing bugs, it seems the patches are stuck in review in llvm. I&#x27;m unsure what directions to take to get more attention to this. &lt;&#x2F;p&gt;
&lt;p&gt;I have also reworked the build process, as well as tagging releases. It is no longer necessary to build LLVM seperately, as I have swapped out the LLVM submodule to the forked one, meaning you can just use normal rust build instructions. Starting now, I will also be tagging releases every time I rebase on upstream master; on top of which I am also offering prebuilt linux (sorry Windows &amp;amp; Mac users) toolchains on the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&#x2F;releases&#x2F;tag&#x2F;xtensa-v0.2.0&quot;&gt;releases&lt;&#x2F;a&gt; (if you are building for Mac or Windows, please feel free to send me your prebuilt toolchains for upload).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling-improvements&quot;&gt;Tooling improvements&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cargo-espflash&quot;&gt;cargo-espflash&lt;&#x2F;h3&gt;
&lt;p&gt;For those of you not familiar with developing on ESP* platforms, there is a flashing tool &lt;code&gt;esptool.py&lt;&#x2F;code&gt; which will flash your program to the device. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; began rewriting this tool in Rust, called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&quot;&gt;espflash&lt;&#x2F;a&gt;. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; then submitted &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;1&quot;&gt;a PR which added a cargo interface&lt;&#x2F;a&gt; to it, meaning we can easily build and flash all in one go, for example building and flashing the blinky example in the ESP32 HAL:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; cargo espflash&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --chip&lt;&#x2F;span&gt;&lt;span&gt; esp32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --example&lt;&#x2F;span&gt;&lt;span&gt; blinky &#x2F;dev&#x2F;ttyUSB0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s really nice to invoke cargo once, make a coffee, and have your code running on the board when you get back! We&#x27;ve been adding more features to the tool, like reading back board info (flash size, CPU revision etc) in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;3&quot;&gt;#3&lt;&#x2F;a&gt;, and allowing faster flash speeds for the ESP32 in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;espflash&#x2F;pull&#x2F;5&quot;&gt;#5&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;idf2svd&quot;&gt;idf2svd&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; submitted a PR to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; to add support for generating ESP8266 SVD&#x27;s, of which the esp8266-hal is built upon; &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust-svd-pac&#x2F;&quot;&gt;if you remeber back to the bonus section of my last post&lt;&#x2F;a&gt;, you will be able to use that SVD to debug ESP8266 applications too!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-runtime-crates&quot;&gt;The runtime crates&lt;&#x2F;h2&gt;
&lt;p&gt;After my last post I set to improve the runtime crate to include support for exceptions, which &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx6-rt&#x2F;pull&#x2F;6&quot;&gt;I started before&lt;&#x2F;a&gt; taking a short break. In that time &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt; championed it, fully implementing exception and interrupt handling for the lx6 CPU of the ESP32! On top of that, for those of you familiar with the &lt;code&gt;cortex-m-rt&lt;&#x2F;code&gt; crates, we implemented the attribute macros for defining &lt;code&gt;#[interrupt]&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;#[exception]&lt;&#x2F;code&gt; handlers and the &lt;code&gt;#[entry]&lt;&#x2F;code&gt; point to the program. Previously &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx6&quot;&gt;&lt;code&gt;xtensa-lx6&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; was empty, but we have since implemented (and moved code from rt where neccessary), including the on chip &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;xtensa-lx6&#x2F;0.2.0&#x2F;xtensa_lx6&#x2F;timer&#x2F;index.html&quot;&gt;timers&lt;&#x2F;a&gt; and a series of &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;xtensa-lx6&#x2F;0.2.0&#x2F;xtensa_lx6&#x2F;mutex&#x2F;index.html&quot;&gt;mutex&lt;&#x2F;a&gt; implementations for the platform.&lt;&#x2F;p&gt;
&lt;p&gt;Meanwhile &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; began writing a runtime crate for the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&#x2F;xtensa-lx106-rt&quot;&gt;lx106&lt;&#x2F;a&gt;, the processor in a ESP8266. We found that between the &lt;code&gt;xtensa-lx&lt;&#x2F;code&gt; series there were not many differences, confirming what a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx-rt&#x2F;issues&#x2F;5#issuecomment-578419057&quot;&gt;core esp-idf developer mentioned&lt;&#x2F;a&gt; previously, therefore we decided to merge the lx6 and lx106 crates producing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx&quot;&gt;&lt;code&gt;xtensa-lx&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;xtensa-lx-rt&quot;&gt;&lt;code&gt;xtensa-lx-rt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with features for each silicon revision.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-hal-crates&quot;&gt;The HAL crates&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;esp32&quot;&gt;ESP32&lt;&#x2F;h3&gt;
&lt;p&gt;With the runtime crates in good shape, we now had a good basis to build a HAL (Hardware abstraction layer). I started by submitting a simple &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;commit&#x2F;8a3f2e750335623b551d59419e4e138659cc77aa&quot;&gt;GPIO driver for the ESP32&lt;&#x2F;a&gt; implementing the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;embedded-hal&quot;&gt;embedded-hal digital traits&lt;&#x2F;a&gt;. Since then the features haven&#x27;t stopped coming, primarily thanks once again to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt;. Checkout &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;tree&#x2F;master&#x2F;examples&quot;&gt;the examples&lt;&#x2F;a&gt; to see what you can do with an ESP32 in pure Rust&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#pure-rust&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;! &lt;&#x2F;p&gt;
&lt;h3 id=&quot;esp8266&quot;&gt;ESP8266&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;icewind1991&quot;&gt;@icewind1991&lt;&#x2F;a&gt; has since started the ESP8266 HAL. One thing that is slowing down development is the fact that alot of the functions in the C SDK are simply binary blobs (or as Espressif refer to them, ROM functions). It means that re-implementing them in Rust requires disassembly  of the binaries and reverse engineering of the assembly to figure out whats going on. Whilst it is undoubtedly fun, it is a lot harder than looking at the source (which we can do with the ESP32). It&#x27;s coming along nicely though, with support for GPIO, Serial, SPI and much more. Checkout the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp8266-hal&quot;&gt;esp-rs&#x2F;esp8266-hal&lt;&#x2F;a&gt; repo. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&quot;&gt;@jessebraham&lt;&#x2F;a&gt; has started a BSP (board support package) for the D1 Mini ESP8266 board, built on top of the esp8266-hal, so if you have one of those board lying around check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jessebraham&#x2F;d1-mini&quot;&gt;repo&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-quickstart&quot;&gt;The quickstart&lt;&#x2F;h2&gt;
&lt;p&gt;With the compiler changes and HAL&#x27;s being created, the old quickstart needed some love. First on the list removing some unneeded compiler restrictions, mainly around allowing debug info generation, as the LLVM fork now supports that (See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;23&quot;&gt;#23&lt;&#x2F;a&gt;). The biggest change has been adding runnable examples for both the ESP32 &amp;amp; ESP8266; its now easier than ever to Rustup your Esp microcontroller! I have also added &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;blob&#x2F;04f9fb79e9a6a519a3311bc1e5a5e22af7c93f29&#x2F;src&#x2F;main.rs#L1-L55&quot;&gt;a brief overview&lt;&#x2F;a&gt; of how to target a different Xtensa target other than the ESP32 or ESP8266, though I&#x27;m not aware of any other boards using this architecture, would be very interested to hear about it if you are aware of any.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;I&#x27;d love to see more contributors as it&#x27;s easier than ever to contribute if you are familiar with Rust or embedded; both HAL&#x27;s are in a good spot to pick a hardware feature and implement it in Rust! &lt;&#x2F;li&gt;
&lt;li&gt;Myself and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arjanmels&quot;&gt;@arjanmels&lt;&#x2F;a&gt; are looking &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-wifi&quot;&gt;at WiFi&#x2F;Bluetooth support&lt;&#x2F;a&gt; for the ESP32, but haven&#x27;t had much luck so far. &lt;&#x2F;li&gt;
&lt;li&gt;At some point I&#x27;d like to start looking into integrating with an existing Rust RTOS, perhaps &lt;a href=&quot;https:&#x2F;&#x2F;www.tockos.org&#x2F;&quot;&gt;tockos&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;rtic.rs&#x2F;0.5&#x2F;book&#x2F;en&#x2F;&quot;&gt;rtic&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;At this point I&#x27;d like to say a big thank you to all the contributors who have helped along the way so far!&lt;&#x2F;p&gt;
&lt;p&gt;Finally, if you appreciate the effort going into this, consider joining @davidkern, @DaMouse404 and others &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;mabezdev&quot;&gt;in sponsoring me&lt;&#x2F;a&gt;, it&#x27;s very much appreciated &amp;lt;3.&lt;&#x2F;p&gt;
&lt;iframe src=&quot;https:&#x2F;&#x2F;github.com&#x2F;sponsors&#x2F;MabezDev&#x2F;card&quot; title=&quot;Sponsor MabezDev&quot; height=&quot;225&quot; width=&quot;600&quot; style=&quot;border: 0;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;br&gt;
&lt;hr &#x2F;&gt;
&lt;br&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;pure-rust&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Not quite! We&#x27;re still using the C bootloader to initialize the flash for now. Note that you can run applications entirely in RAM if you wish.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
        <item>
            <title>Rust on the ESP32 - SVD&#x27;s, PAC&#x27;s and USB flashing</title>
            <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp32-rust-svd-pac/</link>
            <guid>https://mabez.dev/blog/posts/esp32-rust-svd-pac/</guid>
            <description>&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;mabez.dev&#x2F;blog&#x2F;posts&#x2F;esp32-rust&#x2F;&quot;&gt;last post&lt;&#x2F;a&gt; I&#x27;ve been working on building the humble beginnings of an ecosystem around the ESP32 for Rust. The short version of this post is as follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;4&quot;&gt;This PR&lt;&#x2F;a&gt; means the quickstart repo can now flash and run code without a debugger! Simply using the &lt;code&gt;flash&lt;&#x2F;code&gt; or &lt;code&gt;flash_release&lt;&#x2F;code&gt; scripts will flash your code and begin running your code&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; has been created which uses the documentation from &lt;code&gt;esp-idf&lt;&#x2F;code&gt; to generate svd files fit for consumption by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;svd2rust&quot;&gt;svd2rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Based on the generated SVD file, there is now a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;esp32&#x2F;latest&#x2F;esp32&#x2F;&quot;&gt;PAC (Peripheral access crate)&lt;&#x2F;a&gt; for the ESP32.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fixing-xtensa-rust-quickstart&quot;&gt;Fixing &lt;code&gt;xtensa-rust-quickstart&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As noted in my previous post, running Rust applications on the ESP32 required the use of a JTAG debugger as the board would reset repeatedly. My suspicion was a watch dog reset, but my &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&#x2F;pull&#x2F;4&#x2F;commits&#x2F;d8d6971285d20aacb6db32a68138c58a77fa9efa&quot;&gt;initial experiments on disabling the watchdog&lt;&#x2F;a&gt; did not appear to be working. I decided to inspect the openocd source to see what the debugger does when it connects, it turns out that the ESP32 has another 2 timer based watch dogs as seen &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;openocd-esp32&#x2F;blob&#x2F;97ba3a6bb9eaa898d91df923bbedddfeaaaf28c9&#x2F;src&#x2F;target&#x2F;esp32.c#L431&quot;&gt;being disabled by openocd here&lt;&#x2F;a&gt;; after disabling those two watchdogs, its was possible to flash and run code with just the USB cable connected!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-the-esp32-peripheral-access-crate&quot;&gt;Creating the &lt;code&gt;esp32&lt;&#x2F;code&gt; peripheral access crate&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;http:&#x2F;&#x2F;www.keil.com&#x2F;pack&#x2F;doc&#x2F;CMSIS&#x2F;SVD&#x2F;html&#x2F;index.html&quot;&gt;SVD format&lt;&#x2F;a&gt; was created for ARM processors, but as it turns out it works very well for other processor architectures too. Espressif (unsuprisingly) don&#x27;t provide an SVD file, so I would have to create my own; but before I move on to that, what do we actually get from creating and SVD file for the ESP32? Well, it allows us to use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;svd2rust&quot;&gt;svd2rust&lt;&#x2F;a&gt; to generate really nice register access API&#x27;s. In the last post, all peripheral manipulation was achieved through seemingly random volatile writes at given addresses; of course this still needs to happen, but do we need to care about the address and bitshift values? svd2rust hides all of that behind a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;svd2rust&#x2F;0.17.0&#x2F;svd2rust&#x2F;&quot;&gt;simple, well documented API&lt;&#x2F;a&gt; which makes developing higher level abstractions far simpler. For example, disabling the rtc watchdog looks like this: &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;disable_rtc_wdt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rtccntl&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;esp32::RTCCNTL) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Disables write protection *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    rtccntl.wdtwprotect.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;WDT_WKEY_VALUE&lt;&#x2F;span&gt;&lt;span&gt;) });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Disables all wdt stages &amp;amp; the global watchdog flag itself *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    rtccntl.wdtconfig0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        w
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg0&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg1&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg2&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_stg3&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_flashboot_mod_en&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;wdt_en&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Re-enables write protection *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    rtccntl.wdtwprotect.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x0&lt;&#x2F;span&gt;&lt;span&gt;) });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Not a single address or bitshift in sight!&lt;&#x2F;p&gt;
&lt;p&gt;To generate the initial SVD, the data has to come from somewhere. Intially @jeandudey put together an SVD including just the GPIO peripheral, but &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32-hal&#x2F;pull&#x2F;2#issuecomment-565825098&quot;&gt;this approach would be a lot of work&lt;&#x2F;a&gt; to generate info for the entire chip. I decided to explore parsing the info from the esp-idf (Espressif&#x27;s C based HAL&#x2F;libs) code documentation, hence &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&quot;&gt;idf2svd&lt;&#x2F;a&gt; was born; it does a pretty good job of scraping 95%~ of the data we need but &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;idf2svd&#x2F;issues&quot;&gt;there are still a few things&lt;&#x2F;a&gt; that could be improved.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately a lot of the issues with the generated data can be fixed with the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&#x2F;svdtools&quot;&gt;svd patching tool&lt;&#x2F;a&gt;, there have already been a few PR&#x27;s to fix missing peripherals that idf2svd &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32&#x2F;pull&#x2F;8&quot;&gt;missed&lt;&#x2F;a&gt; or &lt;a href=&quot;(https:&#x2F;&#x2F;github.com&#x2F;esp-rs&#x2F;esp32&#x2F;pull&#x2F;7)&quot;&gt;clean up register&lt;&#x2F;a&gt; and bitfield names. Any PR&#x27;s to clean up the SVD are very welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bonus-using-cortex-m-debug-with-the-esp32&quot;&gt;Bonus: Using cortex-m debug with the ESP32&lt;&#x2F;h2&gt;
&lt;p&gt;A side effect of creating the SVD file for svd2rust is that we can now use that SVD file in other applications. The arm developers among you may have heard of an vscode extension called &lt;a href=&quot;https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=marus25.cortex-debug&quot;&gt;cortex-m debug&lt;&#x2F;a&gt;, on top of GDB debugging, it provides really nice info about the state of the registers and peripherals; it does this by, yep you guessed it, using the SVD files that cortex-m silicon vendors provide.&lt;&#x2F;p&gt;
&lt;p&gt;Getting it running with the ESP32 is actually pretty simple; instead of using the arm gdb we will be using &lt;code&gt;xtensa-esp32-elf-gdb&lt;&#x2F;code&gt; which we can get from downloading the &lt;a href=&quot;https:&#x2F;&#x2F;docs.espressif.com&#x2F;projects&#x2F;esp-idf&#x2F;en&#x2F;stable&#x2F;get-started&#x2F;index.html#setup-toolchain&quot;&gt;xtensa toolchain&lt;&#x2F;a&gt; from Espressif, along with their &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;openocd-esp32&quot;&gt;openocd server&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;configuration&quot;&gt;Configuration&lt;&#x2F;h3&gt;
&lt;p&gt;Here is the example configuration taken from &lt;code&gt;xtensa-rust-quickstart&lt;&#x2F;code&gt;; its important to note that cortex-m debug expects the toolchain&#x27;s gdb to be called &lt;code&gt;arm-non-eabi-gdb&lt;&#x2F;code&gt; hence, where ever you specify the toolchain path there must be a file called &lt;code&gt;arm-none-eabi-gdb&lt;&#x2F;code&gt; else it won&#x27;t work. I chose to just symlink &lt;code&gt;xtensa-esp32-elf-gdb&lt;&#x2F;code&gt; to &lt;code&gt;arm-none-eabi-gdb&lt;&#x2F;code&gt; inside that directory.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; the config inside launch.json
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cwd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${workspaceRoot}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;executable&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;target&#x2F;xtensa-esp32-none-elf&#x2F;debug&#x2F;esp32&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;debug-with-svd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;request&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;attach&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cortex-debug&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;servertype&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openocd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;interface&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;jtag&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Download this from the latest `esp32` crate: https:&#x2F;&#x2F;docs.rs&#x2F;esp32&#x2F;latest&#x2F;esp32&#x2F; *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;svdFile&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;svd&#x2F;esp32.svd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; complains about not allowed,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; but it does work.. https:&#x2F;&#x2F;github.com&#x2F;Marus&#x2F;cortex-debug&#x2F;issues&#x2F;111#issuecomment-504778053
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;serverpath&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${env:HOME}&#x2F;programs&#x2F;openocd-esp32&#x2F;bin&#x2F;openocd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; for this to work you will have to run `ln -s xtensa-esp32-elf-gdb arm-none-eabi-gdb`
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;toolchainPath&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;${env:HOME}&#x2F;programs&#x2F;xtensa-esp32-elf&#x2F;bin&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;configFiles&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openocd.cfg&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    ],
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;debug-with-svd.png&quot;&#x2F;&gt;
It even shows you the processor register values!
&lt;img style=&quot;width: 100%; height:auto&quot; src=&quot;&#x2F;xtensa-reg-display.png&quot;&#x2F;&gt;
&lt;p&gt;The best part about this approach is that it&#x27;s language &amp;amp; framework agnostic, meaning if you use the esp-idf, the arduino core or anything else you can still use the SVD even if your not using Rust. Like I said earlier the SVD is still a little rough around the edges, so patches are very welcome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next&lt;&#x2F;h2&gt;
&lt;p&gt;At the time of writing the Espressif have just released there third iteration of their llvm fork, so I will be spending a lot of time building and updating the forks and libraries to support that. The new fork should also fix some long standing and annoying bugs outlined in my first post. Expect another post soon if thats the case!&lt;&#x2F;p&gt;
&lt;p&gt;Finally, if you appreciate the effort going into this project, &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;mabezdev&quot;&gt;consider sponsoring me on Github&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;xtensa-quickstart&lt;&#x2F;a&gt; - A quickstart project for using Rust on xtensa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&quot;&gt;rust-xtensa&lt;&#x2F;a&gt; - The xtensa fork of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&quot;&gt;esp-rs&lt;&#x2F;a&gt; - The &lt;code&gt;esp-rs&lt;&#x2F;code&gt; organization&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&quot;&gt;github&lt;&#x2F;a&gt; - My github&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
</description>
        </item>
        <item>
            <title>Rust on the ESP32</title>
            <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
            <link>https://mabez.dev/blog/posts/esp32-rust/</link>
            <guid>https://mabez.dev/blog/posts/esp32-rust/</guid>
            <description>&lt;p&gt;About six months ago, I made a &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;ar2d3r&#x2F;espressif_have_finally_released_an_llvm_fork_this&#x2F;&quot;&gt;post on reddit&lt;&#x2F;a&gt; highlighting the launch of Espressif&#x27;s llvm xtensa fork, not too long after, I had a working &lt;code&gt;rustc&lt;&#x2F;code&gt; toolchain capable of generating xtensa assembly. At this point I had to put this project to the side to finish my final year of university. Funnily enough I didn&#x27;t stray too far, my final year project used Rust to create a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MWatch&quot;&gt;&#x27;smartwatch&#x27;&lt;&#x2F;a&gt; (I may write about this in the future, if anyone is interested). &lt;&#x2F;p&gt;
&lt;p&gt;Since then I have seen a few posts utilising my fork to run Rust on the &lt;a href=&quot;https:&#x2F;&#x2F;www.espressif.com&#x2F;en&#x2F;products&#x2F;hardware&#x2F;esp32&#x2F;overview&quot;&gt;ESP32&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;dentrassi.de&#x2F;2019&#x2F;06&#x2F;16&#x2F;rust-on-the-esp-and-how-to-get-started&#x2F;&quot;&gt;see this great write up&lt;&#x2F;a&gt; by ctron, if you haven&#x27;t already), most of which are building on top of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-idf&quot;&gt;esp-idf&lt;&#x2F;a&gt; which is written in C. In this post I&#x27;ll be discussing the steps I took to generate valid binaries for the xtensa architecture with &lt;code&gt;rustc&lt;&#x2F;code&gt; and then write some &lt;code&gt;no_std&lt;&#x2F;code&gt; code to build a blinky program for the ESP32 only using Rust!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hacking-the-compiler&quot;&gt;Hacking the compiler&lt;&#x2F;h2&gt;
&lt;p&gt;In March of 2019, Espressif released their first run at an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-xtensa&quot;&gt;llvm fork&lt;&#x2F;a&gt; to support the xtensa architecure. Shortly after I got to work bootstrapping Rust to use this newly created fork. Prior to this project, I&#x27;d had no experience with the compiler, fortunately I came across the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;52787&quot;&gt;RISCV PR&lt;&#x2F;a&gt; which gave me a rough idea of what was required. After &lt;em&gt;many&lt;&#x2F;em&gt; build attempts I finally got it working; I was now able to generate xtensa assembly from Rust source code!&lt;&#x2F;p&gt;
&lt;p&gt;The next step was to assemble and link the generated assembly. The llvm fork in it&#x27;s current state cannot perform object generation, so we must use an external assembler. Luckily Rust allows us to do so by specifying the &lt;code&gt;linker_flavor&lt;&#x2F;code&gt; as &lt;code&gt;gcc&lt;&#x2F;code&gt; and providing a path to the linker with the &lt;code&gt;linker&lt;&#x2F;code&gt; target option, in this case &lt;code&gt;xtensa-esp32-elf-gcc&lt;&#x2F;code&gt;. After that I created a few built-in targets (which you can see &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&#x2F;blob&#x2F;ad570c5cb999f62a03156286fdb5d3d1bbd0fb8b&#x2F;src&#x2F;librustc_target&#x2F;spec&#x2F;xtensa_esp32_none_elf.rs&quot;&gt;here&lt;&#x2F;a&gt;); &lt;code&gt;xtensa-esp32-none-elf&lt;&#x2F;code&gt; for the ESP32; &lt;code&gt;xtensa-esp8266-none-elf&lt;&#x2F;code&gt; for the ESP8266; finally the &lt;code&gt;xtensa-unknown-none-elf&lt;&#x2F;code&gt; target for a generic xtensa target.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blinky-code&quot;&gt;Blinky code&lt;&#x2F;h2&gt;
&lt;p&gt;Now lets try and get a ESP32 board to blink the onboard LED using just Rust. First off, we need our basic program structure. The &lt;code&gt;xtensa_lx6_rt&lt;&#x2F;code&gt; crate does most of the heavy lifting in this respect, we simply need to define an entry point and the panic handler. Some of this may look vaguely familiar if you have any experience with &lt;code&gt;cortex-m&lt;&#x2F;code&gt; development on Rust, I&#x27;ve tried to mirror the API as best as I can.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_std&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_main&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use&lt;&#x2F;span&gt;&lt;span&gt; xtensa_lx6_rt as _;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Entry point - called by xtensa_lx6_rt after initialisation
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Simple panic handler
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;panic_handler&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;panic&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_info&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;PanicInfo) -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now lets add some register definitions for the peripherals we want to use. For our blinky program, we will need to control the GPIO peripheral. In the ESP32 (and most modern processors) peripherals are mapped to memory adresses, commonly refered to as memory mapped peripherals. To control a peripheral we simply need to write values to the right addresses in memory, with respect to the reference manual supplied by the chip manufacturer.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO output enable reg
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_ENABLE_W1TS_REG&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF44024&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO output set register
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_OUT_W1TS_REG&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF44008&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO output clear register
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_OUT_W1TC_REG &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF4400C&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; The GPIO hooked up to the onboard LED
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; GPIO function mode
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_BASE&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3FF44530&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_SEL_CFG&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_BASE &lt;&#x2F;span&gt;&lt;span&gt;+ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using these definitions it should be possible to change the gpio for your board&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#gpio_pin&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; by changing the &lt;code&gt;BLINKY_GPIO&lt;&#x2F;code&gt;; for my board (NODEMCU ESP-32S) it was GPIO2.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;initialisation&quot;&gt;Initialisation&lt;&#x2F;h3&gt;
&lt;p&gt;Next lets setup the pin as a GPIO output. For the ESP32, this is a two step process&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#gpio_pin&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. Firstly, its simply a case of setting a bit in the GPIO ouput enable register. Secondly the pin has to be configured in GPIO mode. There are not enough pins for all the possible peripherals in the chip, to combat this each pin can have multiple function modes. In the case of the ESP32, each pin has up to 256 different functions, although not all are mapped. To put the pin in GPIO mode, we need to put in mode 256 (0x100), we do this by writing to the function select register. After issuing those two register writes, we should be able to turn on the GPIO by setting the relevant bit inside the GPIO set register&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; configure the pin as an output
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        core::ptr::write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_ENABLE_W1TS_REG &lt;&#x2F;span&gt;&lt;span&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span&gt;_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 0x100 makes this pin a simple gpio pin - see the technical reference for more info
&lt;&#x2F;span&gt;&lt;span&gt;        core::ptr::write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_FUNCX_OUT_SEL_CFG &lt;&#x2F;span&gt;&lt;span&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span&gt;_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x100&lt;&#x2F;span&gt;&lt;span&gt;); 
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; turn on the LED
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        core::ptr::write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIO_OUT_W1TS_REG &lt;&#x2F;span&gt;&lt;span&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span&gt;_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; idx);           
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;delaying&quot;&gt;Delaying&lt;&#x2F;h3&gt;
&lt;p&gt;For the next stage of our blinky program, we need a way to delay; a simple approach could use &lt;code&gt;for&lt;&#x2F;code&gt; loop like so.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clocks&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dummy_var: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;_ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..clocks {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::ptr::read_volatile(&amp;amp;dummy_var) };
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add the volatile read so that the compiler doesn&#x27;t optimise our delay away. The problem with this approach is that depending of the optimisation level, the number of clock cycles each iteration of the loop changes. We need a cycle accurate way of delaying, fortunately the ESP32 has an internal clock counting register which can be accessed with the read special register &lt;code&gt;rsr&lt;&#x2F;code&gt; instruction. Now are delay function looks like this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; cycle accurate delay using the cycle counter register
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clocks&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; NOTE: does not account for rollover
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ommitted: the asm to read the ccount
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; target = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ccount&lt;&#x2F;span&gt;&lt;span&gt;() + clocks;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ccount&lt;&#x2F;span&gt;&lt;span&gt;() &amp;gt; target {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have cycle accurate counting we can delay for one second by waiting for the number of cycles the processor will do in one second. The default clock speed on most ESP boards is 40mhz, hence waiting for 40 million cycles equates to a one second delay.&lt;&#x2F;p&gt;
&lt;p&gt;Bringing the snippets together and cleaning up the code into functions, we now have &lt;code&gt;main&lt;&#x2F;code&gt; that looks like this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; configure the pin as an output
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;configure_pin_as_output&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_led&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;CORE_HZ&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_led&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BLINKY_GPIO&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;CORE_HZ&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After flashing to the board, and firing up our JTAG debugger&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, we are greeted with a blinking LED!&lt;&#x2F;p&gt;
&lt;video muted controls style=&quot;width: 100%; height:auto&quot;&gt;
    &lt;source src=&quot;&#x2F;esp-rust-blinky.webm&quot; type=&quot;video&#x2F;mp4&quot;&gt;
&lt;&#x2F;video&gt;
&lt;p&gt;The full source can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;the xtensa quickstart repo&lt;&#x2F;a&gt; if you wish to try it for yourself.&lt;&#x2F;p&gt;
&lt;p&gt;Now I know what most of you are thinking at this point, it&#x27;s not very Rusty; it contains bundles of unsafe and there are no real abstractions here, and you are right; but it&#x27;s something to get the ball rolling.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;&#x2F;h2&gt;
&lt;p&gt;There are a few small teething issues, but by far the biggest being issue is that the fork struggles with generating debug info; the external assembler does not support &lt;a href=&quot;https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs-2.24&#x2F;as&#x2F;CFI-directives.html#CFI-directives&quot;&gt;CFI directives&lt;&#x2F;a&gt; something that all llvm targets need to support. CFI directives can easily be removed with some preprocessing, but does of course add an extra step. After pushing past that issue, I was still getting relocation linker errors. I opened &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;llvm-xtensa&#x2F;issues&#x2F;10&quot;&gt;an issue&lt;&#x2F;a&gt; to document my findings in the hopes it can be sorted in the next iteration of the llvm fork.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;&#x2F;h2&gt;
&lt;p&gt;Once the debuginfo issue is sorted, I hope to start developing an ecosystem of HAL&#x27;s and drivers similar to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&quot;&gt;stm32-rs&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nrf-rs&quot;&gt;nrf-rs&lt;&#x2F;a&gt;; I&#x27;ve already started the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;esp-rs&quot;&gt;esp-rs&lt;&#x2F;a&gt; organization which is where &lt;code&gt;xtensa-lx6-rt&lt;&#x2F;code&gt; currently resides. Espressif has started the upstream process, the first ten patches are now in review, there should be an update coming to their fork moving from the older llvm6 to llvm8 (and hopefully some other additions and fixes too!).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;xtensa-rust-quickstart&quot;&gt;xtensa-quickstart&lt;&#x2F;a&gt; - A quickstart project for using Rust on xtensa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&#x2F;rust-xtensa&quot;&gt;rust-xtensa&lt;&#x2F;a&gt; - The xtensa fork of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MabezDev&quot;&gt;github&lt;&#x2F;a&gt; - My github&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br&#x2F;&gt;
&lt;hr &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;gpio_pin&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Note that this only applies for GPIO&#x27;s 0 to 31, the rest of the GPIO&#x27;s use a different register.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;This is not always the case if the pin the LED is connected to does not default to the correct iomux function, see the quickstart example for more info.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;This step is actually very important, currently the board will reset endlessly on boot (I assume due to the watch dog not being disabled), but launching with the debugger works as expected.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
    </channel>
</rss>
